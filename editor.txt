We set up an environment to compile and run programs in the C language.
The program we are building doesn’t depend on any external libraries, so we need only a C compiler and its standard library. We will also use the make program. To check whether you have a C compiler installed, run cc --version at the command line. cc stands for “C Compiler”. To check whether you have make, run make -v.

For windows you must first install a Linux environment. This is because our text editor interacts with the terminal at a low level using the termios.h. header. It may be better to use either Bash on Windows or Cygwin.

Bash on Windows works on 64-bit Windows 10. See the installation guide. After installing it, run bash at the command line whenever you want to enter the Linux environment. Inside bash, run sudo apt-get install gcc make to install the GNU Compiler Collection and the make program. If sudo takes a really long time to do anything, you may have to fix your /etc/hosts file.

for Cygwin, Download the installer from cygwin.com/install.html. When the installer asks you to select packages to install, look in the devel category and select the gcc-core and make packages. To use Cygwin, you have to run the Cygwin terminal program. Unlike Bash on Windows, in Cygwin your home directory is separate from your Windows home directory. If you installed Cygwin to C:\cygwin64, then your home directory is at C:\cygwin64\home\yourname. So if you want to use a text editor outside of Cygwin to write your code, that’s where you’ll want to save to.

in macOS When you try to run the cc command, a window should pop up asking if you want to install the command line developer tools. You can also run xcode-select --install to get this window to pop up. Then just click “Install” and it will install a C compiler and make, among other things.

In Ubuntu, it’s sudo apt-get install gcc make. Other distributions should have gcc and make packages available as well.
The main() function.
Create a new file named kilo.c and give it a main() function.

main
int main() {
  return 0;
}

In C, you have to put all your executable code inside functions. The main() function in C is special. It is the default starting point when you run your program. When you return from the main() function, the program exits and passes the returned integer back to the operating system. A return value of 0 indicates success.

C is a compiled language. That means we need to run our program through a C compiler to turn it into an executable file. We then run that executable like we would run any other program on the command line.

To compile kilo.c, run cc kilo.c -o kilo in your shell. If no errors occur, this will produce an executable named kilo. -o stands for “output”, and specifies that the output executable should be named kilo.

To run kilo, type ./kilo in your shell and press Enter. The program doesn’t print any output, but you can check its exit status (the value main() returns) by running echo $?, which should print 0.

Compiling with make. Typing cc kilo.c -o kilo every time you want to recompile gets tiring. The make program allows you to simply run make and it will compile your program for you. You just have to supply a Makefile to tell it how to compile your program.

Create a file named Makefile with these contents.

make, kilo, kilo.c $(CC) kilo.c -o kilo -Wall -Wextra -pedantic -std=c99

The first line says that kilo is what we want to build, and that kilo.c is what’s required to build it. The second line specifies the command to run in order to actually build kilo out of kilo.c. Make sure to indent the second line with an actual tab character, and not with spaces. You can indent C files however you want, but Makefiles must use tabs.

We have added a few things to the compilation command:

$(CC) is a variable that make expands to cc by default.
-Wall stands for “all Warnings”, and gets the compiler to warn you when it sees code in your program that might not technically be wrong, but is considered bad or questionable usage of the C language, like using variables before initializing them.
-Wextra and -pedantic turn on even more warnings. For each step in this tutorial, if your program compiles, it shouldn’t produce any warnings except for “unused variable” warnings in some cases. If you get any other warnings, check to make sure your code exactly matches the code in that step.
-std=c99 specifies the exact version of the C language standard we’re using, which is C99. C99 allows us to declare variables anywhere within a function, whereas ANSI C requires all variables to be declared at the top of a function or block.
Now that we have a Makefile, try running make to compile the program.

After each step in this tutorial, you will want to recompile kilo.c, see if it finds any errors in your code, and then run ./kilo. It is easy to forget to recompile, and just run ./kilo, and wonder why your changes to kilo.c don’t seem to have any effect. You must recompile in order for changes in kilo.c to be reflected in kilo.

Next we’ll work on getting the terminal into raw mode, and reading individual keypresses from the user.

Entering raw mode. This lets us read keypresses from the user and respond in real time.

include unistd.h.

  while (read(standard in FILENO, &c, 1) == 1);
  

read() and standard in FILENO come from unistd.h. We are asking read() to read 1 byte from the standard input into the variable c, and to keep doing it until there are no more bytes to read. read() returns the number of bytes that it read, and will return 0 when it reaches the end of a file.

When you run ./kilo, your terminal gets hooked up to the standard input, and so your keyboard input gets read into the c variable. However, by default your terminal starts in canonical mode, also called cooked mode. In this mode, keyboard input is only sent to your program when the user presses Enter. This is useful for many programs: it lets the user type in a line of text, use Backspace to fix errors until they get their input exactly the way they want it, and finally press Enter to send it to the program. But it does not work well for programs with more complex user interfaces, like text editors. We want to process each keypress as it comes in, so we can respond to it immediately.

What we want is raw mode. Unfortunately, there is no simple switch you can flip to set the terminal to raw mode. Raw mode is achieved by turning off a great many flags in the terminal, which we will do gradually over the course of this chapter.

To exit the above program, press Ctrl-D to tell read() that it’s reached the end of file. Or you can always press Ctrl-C to signal the process to terminate immediately.

To demonstrate how canonical mode works, we’ll have the program exit when it reads a q keypress from the user. (Lines you need to change are highlighted and marked the same way as lines you need to add.)



  while (read(standard in FILENO, &c, 1) == 1 && c != 'q');
  

To quit this program, you will have to type a line of text that includes a q in it, and then press enter. The program will quickly read the line of text one character at a time until it reads the q, at which point the while loop will stop and the program will exit. Any characters after the q will be left unread on the input queue, and you may see that input being fed into your shell after your program exits.

Turn off echoing
We can set a terminal’s attributes by (1) using tcgetattr() to read the current attributes into a struct, (2) modifying the struct by hand, and (3) passing the modified struct to tcsetattr() to write the new terminal attributes back out. Let’s try turning off the ECHO feature this way.

include termios.h.

void enableRawMode() {
  struct termios raw;
  tcgetattr(standard in FILENO, &raw);
  raw.c lflag &= ~(ECHO);
  tcsetattr(standard in FILENO, TCSAFLUSH, &raw);
}
int main() {
  enableRawMode();
  char c;
  while (read(standard in FILENO, &c, 1) == 1 && c != 'q');
  

struct termios, tcgetattr(), tcsetattr(), ECHO, and TCSAFLUSH all come from termios.h.

The ECHO feature causes each key you type to be printed to the terminal, so you can see what you’re typing. This is useful in canonical mode, but really gets in the way when we are trying to carefully render a user interface in raw mode. So we turn it off. This program does the same thing as the one in the previous step, it just doesn’t print what you are typing. You may be familiar with this mode if you’ve ever had to type a password at the terminal, when using sudo for example.

After the program quits, depending on your shell, you may find your terminal is still not echoing what you type. Don’t worry, it will still listen to what you type. Just press Ctrl-C to start a fresh line of input to your shell, and type in reset and press Enter. This resets your terminal back to normal in most cases. Failing that, you can always restart your terminal emulator. We’ll fix this whole problem in the next step.

Terminal attributes can be read into a termios struct by tcgetattr(). After modifying them, you can then apply them to the terminal using tcsetattr(). The TCSAFLUSH argument specifies when to apply the change: in this case, it waits for all pending output to be written to the terminal, and also discards any input that hasn’t been read.

The c lflag field is for “local flags”. A comment in macOS’s termios.h. describes it as a “dumping ground for other state”. So perhaps it should be thought of as “miscellaneous flags”. The other flag fields are c iflag (input flags), c oflag (output flags), and c cflag (control flags), all of which we will have to modify to enable raw mode.

ECHO is a bitflag, defined as 00000000000000000000000000001000 in binary. We use the bitwise-NOT operator (~) on this value to get 11111111111111111111111111110111. We then bitwise-AND this value with the flags field, which forces the fourth bit in the flags field to become 0, and causes every other bit to retain its current value. Flipping bits like this is common in C.

We’ll save a copy of the termios struct in its original state, and use tcsetattr() to apply it to the terminal when the program exits.

include standard lib.h.

struct termios orig termios;
void disableRawMode() {
  tcsetattr(standard in FILENO, TCSAFLUSH, &orig termios);
}
void enableRawMode() {
  tcgetattr(standard in FILENO, &orig termios);
  atexit(disableRawMode);
  struct termios raw = orig termios;
  raw.c lflag &= ~(ECHO);
  tcsetattr(standard in FILENO, TCSAFLUSH, &raw);
}

atexit() comes from standard lib.h. We use it to register our disableRawMode() function to be called automatically when the program exits, whether it exits by returning from main(), or by calling the exit() function. This way we can ensure we’ll leave the terminal attributes the way we found them when our program exits.

We store the original terminal attributes in a global variable, orig termios. We assign the orig termios struct to the raw struct in order to make a copy of it before we start making our changes.

You may notice that leftover input is no longer fed into your shell after the program quits. This is because of the TCSAFLUSH option being passed to tcsetattr() when the program exits. As described earlier, it discards any unread input before applying the changes to the terminal. (Note: This doesn’t happen in Cygwin for some reason, but it won’t matter once we are reading input one byte at a time.)

There is an ICANON flag that allows us to turn off canonical mode. This means we will finally be reading input byte-by-byte, instead of line-by-line.

void enableRawMode() {
  tcgetattr(standard in FILENO, &orig termios);
  atexit(disableRawMode);
  struct termios raw = orig termios;
  raw.c lflag &= ~(ECHO | ICANON);
  tcsetattr(standard in FILENO, TCSAFLUSH, &raw);
}

ICANON comes from termios.h. Input flags (the ones in the c iflag field) generally start with I like ICANON does. However, ICANON is not an input flag, it’s a “local” flag in the c lflag field. So that’s confusing.

Now the program will quit as soon as you press q.
To get a better idea of how input in raw mode works, let’s print out each byte that we read(). We’ll print each character’s numeric ASCII value, as well as the character it represents if it is a printable character.

include ctype.h.
include stdio.h.

int main() {
  enableRawMode();
  char c;
  while (read(standard in FILENO, &c, 1) == 1 && c != 'q') {
    if (iscntrl(c)) {
      print F ("%d\n", c);
    } else {
      print F ("%d ('%c')\n", c, c);
    }
  }
  

iscntrl() comes from <ctype.h., and print F () comes from standard I O dot H.

iscntrl() tests whether a character is a control character. Control characters are nonprintable characters that we don’t want to print to the screen. ASCII codes 0–31 are all control characters, and 127 is also a control character. ASCII codes 32–126 are all printable. (Check out the ASCII table to see all of the characters.)

print F () can print multiple representations of a byte. %d tells it to format the byte as a decimal number (its ASCII code), and %c tells it to write out the byte directly, as a character.

This is a very useful program. It shows us how various keypresses translate into the bytes we read. Most ordinary keys translate directly into the characters they represent. But try seeing what happens when you press the arrow keys, or Escape, or Page Up, or Page Down, or Home, or End, or Backspace, or Delete, or Enter. Try key combinations with Ctrl, like Ctrl-A, Ctrl-B, etc.

You’ll notice a few interesting things:

Arrow keys, Page Up, Page Down, Home, and End all input 3 or 4 bytes to the terminal: 27, '[', and then one or two other characters. This is known as an escape sequence. All escape sequences start with a 27 byte. Pressing Escape sends a single 27 byte as input.
Backspace is byte 127. Delete is a 4-byte escape sequence.
Enter is byte 10, which is a newline character, also known as '\n'.
Ctrl-A is 1, Ctrl-B is 2, Ctrl-C is… oh, that terminates the program, right. But the Ctrl key combinations that do work seem to map the letters A–Z to the codes 1–26.
By the way, if you happen to press Ctrl-S, you may find your program seems to be frozen. What you’ve done is you’ve asked your program to stop sending you output. Press Ctrl-Q to tell it to resume sending you output.

Also, if you press Ctrl-Z (or maybe Ctrl-Y), your program will be suspended to the background. Run the fg command to bring it back to the foreground. (It may quit immediately after you do that, as a result of read() returning -1 to indicate that an error occurred. This happens on macOS, while Linux seems to be able to resume the read() call properly.)

Turn off Ctrl-C and Ctrl-Z signals
By default, Ctrl-C sends a SIGINT signal to the current process which causes it to terminate, and Ctrl-Z sends a SIGTSTP signal to the current process which causes it to suspend. Let’s turn off the sending of both of these signals.

void enableRawMode() {
  tcgetattr(standard in FILENO, &orig termios);
  atexit(disableRawMode);
  struct termios raw = orig termios;
  raw.c lflag &= ~(ECHO | ICANON | ISIG);
  tcsetattr(standard in FILENO, TCSAFLUSH, &raw);
}

ISIG comes from termios.h. Like ICANON, it starts with I but isn’t an input flag.

Now Ctrl-C can be read as a 3 byte and Ctrl-Z can be read as a 26 byte.

This also disables Ctrl-Y on macOS, which is like Ctrl-Z except it waits for the program to read input before suspending it.

By default, Ctrl-S and Ctrl-Q are used for software flow control. Ctrl-S stops data from being transmitted to the terminal until you press Ctrl-Q. This originates in the days when you might want to pause the transmission of data to let a device like a printer catch up. Let’s just turn off that feature.

void enableRawMode() {
  tcgetattr(standard in FILENO, &orig termios);
  atexit(disableRawMode);
  struct termios raw = orig termios;
  raw.c iflag &= ~(IXON);
  raw.c lflag &= ~(ECHO | ICANON | ISIG);
  tcsetattr(standard in FILENO, TCSAFLUSH, &raw);
}

IXON comes from termios.h. The I stands for “input flag” (which it is, unlike the other I flags we’ve seen so far) and XON comes from the names of the two control characters that Ctrl-S and Ctrl-Q produce: XOFF to pause transmission and XON to resume transmission.

Now Ctrl-S can be read as a 19 byte and Ctrl-Q can be read as a 17 byte.
On some systems, when you type Ctrl-V, the terminal waits for you to type another character and then sends that character literally. For example, before we disabled Ctrl-C, you might’ve been able to type Ctrl-V and then Ctrl-C to input a 3 byte. We can turn off this feature using the IEXTEN flag.

Turning off IEXTEN also fixes Ctrl-O in macOS, whose terminal driver is otherwise set to discard that control character.

void enableRawMode() {
  tcgetattr(standard in FILENO, &orig termios);
  atexit(disableRawMode);
  struct termios raw = orig termios;
  raw.c iflag &= ~(IXON);
  raw.c lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  tcsetattr(standard in FILENO, TCSAFLUSH, &raw);
}
IEXTEN comes from termios.h. It is another flag that starts with I but belongs in the c lflag field.

Ctrl-V can now be read as a 22 byte, and Ctrl-O as a 15 byte.

If you run the program now and go through the whole alphabet while holding down Ctrl, you should see that we have every letter except M. Ctrl-M is weird: it’s being read as 10, when we expect it to be read as 13, since it is the 13th letter of the alphabet, and Ctrl-J already produces a 10. What else produces 10? The Enter key does.

It turns out that the terminal is helpfully translating any carriage returns (13, '\r') inputted by the user into newlines (10, '\n'). Let’s turn off this feature.

void enableRawMode() {
  tcgetattr(standard in FILENO, &orig termios);
  atexit(disableRawMode);
  struct termios raw = orig termios;
  raw.c iflag &= ~(ICRNL | IXON);
  raw.c lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  tcsetattr(standard in FILENO, TCSAFLUSH, &raw);
}

ICRNL comes from termios.h. The I stands for “input flag”, CR stands for “carriage return”, and NL stands for “new line”.

Now Ctrl-M is read as a 13 (carriage return), and the Enter key is also read as a 13.

It turns out that the terminal does a similar translation on the output side. It translates each newline ("\n") we print into a carriage return followed by a newline ("\r\n"). The terminal requires both of these characters in order to start a new line of text. The carriage return moves the cursor back to the beginning of the current line, and the newline moves the cursor down a line, scrolling the screen if necessary. (These two distinct operations originated in the days of typewriters and teletypes.)

We will turn off all output processing features by turning off the OPOST flag. In practice, the "\n" to "\r\n" translation is likely the only output processing feature turned on by default.

void enableRawMode() {
  tcgetattr(standard in FILENO, &orig termios);
  atexit(disableRawMode);
  struct termios raw = orig termios;
  raw.c iflag &= ~(ICRNL | IXON);
  raw.c oflag &= ~(OPOST);
  raw.c lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  tcsetattr(standard in FILENO, TCSAFLUSH, &raw);
}

OPOST comes from termios.h. O means it’s an output flag, and I assume POST stands for “post-processing of output”.

If you run the program now, you’ll see that the newline characters we’re printing are only moving the cursor down, and not to the left side of the screen. To fix that, let’s add carriage returns to our print F () statements.

int main() {
  enableRawMode();
  char c;
  while (read(standard in FILENO, &c, 1) == 1 && c != 'q') {
    if (iscntrl(c)) {
      print F ("%d\r\n", c);
    } else {
      print F ("%d ('%c')\r\n", c, c);
    }
  }
  

From now on, we’ll have to write out the full "\r\n" whenever we want to start a new line.
Let’s turn off a few more flags.

void enableRawMode() {
  tcgetattr(standard in FILENO, &orig termios);
  atexit(disableRawMode);
  struct termios raw = orig termios;
  raw.c iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  raw.c oflag &= ~(OPOST);
  raw.c cflag |= (CS8);
  raw.c lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  tcsetattr(standard in FILENO, TCSAFLUSH, &raw);
}

BRKINT, INPCK, ISTRIP, and CS8 all come from termios.h.

This step probably won’t have any observable effect for you, because these flags are either already turned off, or they don’t really apply to modern terminal emulators. But at one time or another, switching them off was considered (by someone) to be part of enabling “raw mode”, so we carry on the tradition (of whoever that someone was) in our program.

As far as I can tell:

When BRKINT is turned on, a break condition will cause a SIGINT signal to be sent to the program, like pressing Ctrl-C.
INPCK enables parity checking, which doesn’t seem to apply to modern terminal emulators.
ISTRIP causes the 8th bit of each input byte to be stripped, meaning it will set it to 0. This is probably already turned off.
CS8 is not a flag, it is a bit mask with multiple bits, which we set using the bitwise-OR (|) operator unlike all the flags we are turning off. It sets the character size (CS) to 8 bits per byte. On my system, it’s already set that way.
A timeout for read()
Currently, read() will wait indefinitely for input from the keyboard before it returns. What if we want to do something like animate something on the screen while waiting for user input? We can set a timeout, so that read() returns if it doesn’t get any input for a certain amount of time.

void enableRawMode() {
  tcgetattr(standard in FILENO, &orig termios);
  atexit(disableRawMode);
  struct termios raw = orig termios;
  raw.c iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  raw.c oflag &= ~(OPOST);
  raw.c cflag |= (CS8);
  raw.c lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  raw.c cc[VMIN] = 0;
  raw.c cc[VTIME] = 1;
  tcsetattr(standard in FILENO, TCSAFLUSH, &raw);
}
int main() {
  enableRawMode();
  while (1) {
    char c = '\0';
    read(standard in FILENO, &c, 1);
    if (iscntrl(c)) {
      print F ("%d\r\n", c);
    } else {
      print F ("%d ('%c')\r\n", c, c);
    }
    if (c == 'q') break;
  }
  

VMIN and VTIME come from termios.h. They are indexes into the c cc field, which stands for “control characters”, an array of bytes that control various terminal settings.

The VMIN value sets the minimum number of bytes of input needed before read() can return. We set it to 0 so that read() returns as soon as there is any input to be read. The VTIME value sets the maximum amount of time to wait before read() returns. It is in tenths of a second, so we set it to 1/10 of a second, or 100 milliseconds. If read() times out, it will return 0, which makes sense because its usual return value is the number of bytes read.

When you run the program, you can see how often read() times out. If you don’t supply any input, read() returns without setting the c variable, which retains its 0 value and so you see 0s getting printed out. If you type really fast, you can see that read() returns right away after each keypress, so it’s not like you can only read one keypress every tenth of a second.

If you’re using Bash on Windows, you may see that read() still blocks for input. It doesn’t seem to care about the VTIME value. Fortunately, this won’t make too big a difference in our text editor, as we’ll be basically blocking for input anyways.

enableRawMode() now gets us fully into raw mode. It’s time to clean up the code by adding some error handling.

First, we’ll add a die() function that prints an error message and exits the program.

void die(const char *s) {
  perror(s);
  exit(1);
}

perror() comes from standard I O dot H., and exit() comes from standard lib.h.

Most C library functions that fail will set the global errno variable to indicate what the error was. perror() looks at the global errno variable and prints a descriptive error message for it. It also prints the string given to it before it prints the error message, which is meant to provide context about what part of your code caused the error.

After printing out the error message, we exit the program with an exit status of 1, which indicates failure (as would any non-zero value).

Let’s check each of our library calls for failure, and call die() when they fail.


include errno.h.

void disableRawMode() {
  if (tcsetattr(standard in FILENO, TCSAFLUSH, &orig termios) == -1)
    die("tcsetattr");
}
void enableRawMode() {
  if (tcgetattr(standard in FILENO, &orig termios) == -1) die("tcgetattr");
  atexit(disableRawMode);
  struct termios raw = orig termios;
  raw.c iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  raw.c oflag &= ~(OPOST);
  raw.c cflag |= (CS8);
  raw.c lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  raw.c cc[VMIN] = 0;
  raw.c cc[VTIME] = 1;
  if (tcsetattr(standard in FILENO, TCSAFLUSH, &raw) == -1) die("tcsetattr");
}
int main() {
  enableRawMode();
  while (1) {
    char c = '\0';
    if (read(standard in FILENO, &c, 1) == -1 && errno != EAGAIN) die("read");
    if (iscntrl(c)) {
      print F ("%d\r\n", c);
    } else {
      print F ("%d ('%c')\r\n", c, c);
    }
    if (c == 'q') break;
  }
  

errno and EAGAIN come from <errno.h.

tcsetattr(), tcgetattr(), and read() all return -1 on failure, and set the errno value to indicate the error.

In Cygwin, when read() times out it returns -1 with an errno of EAGAIN, instead of just returning 0 like it’s supposed to. To make it work in Cygwin, we won’t treat EAGAIN as an error.

An easy way to make tcgetattr() fail is to give your program a text file or a pipe as the standard input instead of your terminal. To give it a file as standard input, run ./kilo <kilo.c. To give it a pipe, run echo test | ./kilo. Both should result in the same error from tcgetattr(), something like Inappropriate ioctl for device.

That just about concludes the part on entering raw mode. The last thing we’ll do now is split our code into sections. This will allow these diffs to be shorter, as each section that isn’t changed in a diff will be folded into a single line.

next we’ll do some more low-level terminal input/output handling, and use that to draw to the screen and allow the user to move the cursor around.

Raw input and output. Press Ctrl-Q to quit. we saw that the Ctrl key combined with the alphabetic keys seemed to map to bytes 1–26. We can use this to detect Ctrl key combinations and map them to different operations in our editor. We’ll start by mapping Ctrl-Q to the quit operation.



define CTRL KEY(k) ((k) & 0x1f)



int main() {
  enableRawMode();
  while (1) {
    char c = '\0';
    if (read(standard in FILENO, &c, 1) == -1 && errno != EAGAIN) die("read");
    if (iscntrl(c)) {
      print F ("%d\r\n", c);
    } else {
      print F ("%d ('%c')\r\n", c, c);
    }
    if (c == CTRL KEY('q')) break;
  }
  

The CTRL KEY macro bitwise-ANDs a character with the value 00011111, in binary. (In C, you generally specify bitmasks using hexadecimal, since C doesn’t have binary literals, and hexadecimal is more concise and readable once you get used to it.) In other words, it sets the upper 3 bits of the character to 0. This mirrors what the Ctrl key does in the terminal: it strips bits 5 and 6 from whatever key you press in combination with Ctrl, and sends that. (By convention, bit numbering starts from 0.) The ASCII character set seems to be designed this way on purpose. (It is also similarly designed so that you can set and clear bit 5 to switch between lowercase and uppercase.)

Refactor keyboard input. Let’s make a function for low-level keypress reading, and another function for mapping keypresses to editor operations. We’ll also stop printing out keypresses at this point. refactor-input.

char editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  return c;
}

void editorProcessKeypress() {
  char c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      exit(0);
      break;
  }
}

int main() {
  enableRawMode();
  while (1) {
    editorProcessKeypress();
  }
  

editorReadKey()’s job is to wait for one keypress, and return it. Later, we’ll expand this function to handle escape sequences, which involves reading multiple bytes that represent a single keypress, as is the case with the arrow keys.

editorProcessKeypress() waits for a keypress, and then handles it. Later, it will map various Ctrl key combinations and other special keys to different editor functions, and insert any alphanumeric and other printable keys’ characters into the text that is being edited.

Note that editorReadKey() belongs in the  section because it deals with low-level terminal input, whereas editorProcessKeypress() belongs in the new  section because it deals with mapping keys to editor functions at a much higher level.

Now we have vastly simplified main(), and we will try to keep it that way.

Clear the screen. We’re going to render the editor’s user interface to the screen after each keypress. Let’s start by just clearing the screen.

void editorRefreshScreen() {
  write(standard out FILENO, "\x1b[2J", 4);
}


int main() {
  enableRawMode();
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }
  

write() and standard out FILENO come from unistd.h.

The 4 in our write() call means we are writing 4 bytes out to the terminal. The first byte is \x1b, which is the escape character, or 27 in decimal. (Try and remember \x1b, we will be using it a lot.) The other three bytes are [2J.

We are writing an escape sequence to the terminal. Escape sequences always start with an escape character (27) followed by a [ character. Escape sequences instruct the terminal to do various text formatting tasks, such as coloring text, moving the cursor around, and clearing parts of the screen.

We are using the J command (Erase In Display) to clear the screen. Escape sequence commands take arguments, which come before the command. In this case the argument is 2, which says to clear the entire screen. <esc>[1J would clear the screen up to where the cursor is, and <esc>[0J would clear the screen from the cursor up to the end of the screen. Also, 0 is the default argument for J, so just <esc>[J by itself would also clear the screen from the cursor to the end.

For our text editor, we will be mostly using VT100 escape sequences, which are supported very widely by modern terminal emulators. See the VT100 User Guide for complete documentation of each escape sequence.

If we wanted to support the maximum number of terminals out there, we could use the ncurses library, which uses the terminfo database to figure out the capabilities of a terminal and what escape sequences to use for that particular terminal. Reposition the cursor. You may notice that the <esc>[2J command left the cursor at the bottom of the screen. Let’s reposition it at the top-left corner so that we’re ready to draw the editor interface from top to bottom.

void editorRefreshScreen() {
  write(standard out FILENO, "\x1b[2J", 4);
  write(standard out FILENO, "\x1b[H", 3);
}

This escape sequence is only 3 bytes long, and uses the H command (Cursor Position) to position the cursor. The H command actually takes two arguments: the row number and the column number at which to position the cursor. So if you have an 80×24 size terminal and you want the cursor in the center of the screen, you could use the command <esc>[12;40H. (Multiple arguments are separated by a ; character.) The default arguments for H both happen to be 1, so we can leave both arguments out and it will position the cursor at the first row and first column, as if we had sent the <esc>[1;1H command. (Rows and columns are numbered starting at 1, not 0.)

Clear the screen on exit. Let’s clear the screen and reposition the cursor when our program exits. If an error occurs in the middle of rendering the screen, we don’t want a bunch of garbage left over on the screen, and we don’t want the error to be printed wherever the cursor happens to be at that point.

void die(const char *s) {
  write(standard out FILENO, "\x1b[2J", 4);
  write(standard out FILENO, "\x1b[H", 3);
  perror(s);
  exit(1);
}


void editorProcessKeypress() {
  char c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
  }
}

We have two exit points we want to clear the screen at: die(), and when the user presses Ctrl-Q to quit.

We could use atexit() to clear the screen when our program exits, but then the error message printed by die() would get erased right after printing it.

Tildes. It’s time to start drawing. Let’s draw a column of tildes (~) on the left hand side of the screen, like vim does. In our text editor, we’ll draw a tilde at the beginning of any lines that come after the end of the file being edited.

void editorDrawRows() {
  int y;
  for (y = 0; y < 24; y++) {
    write(standard out FILENO, "~\r\n", 3);
  }
}
void editorRefreshScreen() {
  write(standard out FILENO, "\x1b[2J", 4);
  write(standard out FILENO, "\x1b[H", 3);
  editorDrawRows();
  write(standard out FILENO, "\x1b[H", 3);
}



editorDrawRows() will handle drawing each row of the buffer of text being edited. For now it draws a tilde in each row, which means that row is not part of the file and can’t contain any text.

We don’t know the size of the terminal yet, so we don’t know how many rows to draw. For now we just draw 24 rows.

After we’re done drawing, we do another <esc>[H escape sequence to reposition the cursor back up at the top-left corner.

Global state. Our next goal is to get the size of the terminal, so we know how many rows to draw in editorDrawRows(). But first, let’s set up a global struct that will contain our editor state, which we’ll use to store the width and height of the terminal. For now, let’s just put our orig termios global into the struct.

struct editorConfig {
  struct termios orig termios;
};
struct editorConfig E;

void disableRawMode() {
  if (tcsetattr(standard in FILENO, TCSAFLUSH, &E.orig termios) == -1)
    die("tcsetattr");
}
void enableRawMode() {
  if (tcgetattr(standard in FILENO, &E.orig termios) == -1) die("tcgetattr");
  atexit(disableRawMode);
  struct termios raw = E.orig termios;
  raw.c iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  raw.c oflag &= ~(OPOST);
  raw.c cflag |= (CS8);
  raw.c lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  raw.c cc[VMIN] = 0;
  raw.c cc[VTIME] = 1;
  if (tcsetattr(standard in FILENO, TCSAFLUSH, &raw) == -1) die("tcsetattr");
}



Our global variable containing our editor state is named E. We must replace all occurrences of orig termios with E.orig termios.

Window size, the easy way
On most systems, you should be able to get the size of the terminal by simply calling ioctl() with the TIOCGWINSZ request. (As far as I can tell, it stands for Terminal IOCtl (which itself stands for Input/Output Control) Get WINdow SiZe.)





include sys/ioctl.h.




int getWindowSize(int *rows, int *cols) {
  struct winsize ws;
  if (ioctl(standard out FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws col == 0) {
    return -1;
  } else {
    *cols = ws.ws col;
    *rows = ws.ws row;
    return 0;
  }
}


ioctl(), TIOCGWINSZ, and struct winsize come from <sys/ioctl.h.

On success, ioctl() will place the number of columns wide and the number of rows high the terminal is into the given winsize struct. On failure, ioctl() returns -1. We also check to make sure the values it gave back weren’t 0, because apparently that’s a possible erroneous outcome. If ioctl() failed in either way, we have getWindowSize() report failure by returning -1. If it succeeded, we pass the values back by setting the int references that were passed to the function. (This is a common approach to having functions return multiple values in C. It also allows you to use the return value to indicate success or failure.)

Now let’s add screenrows and screencols to our global editor state, and call getWindowSize() to fill in those values.

struct editorConfig {
  int screenrows;
  int screencols;
  struct termios orig termios;
};
struct editorConfig E;

void initEditor() {
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
int main() {
  enableRawMode();
  initEditor();
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }
  

initEditor()’s job will be to initialize all the fields in the E struct.

Now we’re ready to display the proper number of tildes on the screen:

void editorDrawRows() {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    write(standard out FILENO, "~\r\n", 3);
  }
}

Window size, the hard way. ioctl() isn’t guaranteed to be able to request the window size on all systems, so we are going to provide a fallback method of getting the window size.

The strategy is to position the cursor at the bottom-right of the screen, then use escape sequences that let us query the position of the cursor. That tells us how many rows and columns there must be on the screen.

Let’s start by moving the cursor to the bottom-right.

int getWindowSize(int *rows, int *cols) {
  struct winsize ws;
  if (1 || ioctl(standard out FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws col == 0) {
    if (write(standard out FILENO, "\x1b[999C\x1b[999B", 12) != 12) return -1;
    editorReadKey();
    return -1;
  } else {
    *cols = ws.ws col;
    *rows = ws.ws row;
    return 0;
  }
}

As you might have gathered from the code, there is no simple “move the cursor to the bottom-right corner” command.

We are sending two escape sequences one after the other. The C command (Cursor Forward) moves the cursor to the right, and the B command (Cursor Down) moves the cursor down. The argument says how much to move it right or down by. We use a very large value, 999, which should ensure that the cursor reaches the right and bottom edges of the screen.

The C and B commands are specifically documented to stop the cursor from going past the edge of the screen. The reason we don’t use the <esc>[999;999H command is that the documentation doesn’t specify what happens when you try to move the cursor off-screen.

Note that we are sticking a 1 || at the front of our if condition temporarily, so that we can test this fallback branch we are developing.

Because we’re always returning -1 (meaning an error occurred) from getWindowSize() at this point, we make a call to editorReadKey() so we can observe the results of our escape sequences before the program calls die() and clears the screen. When you run the program, you should see the cursor is positioned at the bottom-right corner of the screen, and then when you press a key you’ll see the error message printed by die() after it clears the screen.

Next we need to get the cursor position. The n command (Device Status Report) can be used to query the terminal for status information. We want to give it an argument of 6 to ask for the cursor position. Then we can read the reply from the standard input. Let’s print out each character from the standard input to see what the reply looks like.

int getCursorPosition(int *rows, int *cols) {
  if (write(standard out FILENO, "\x1b[6n", 4) != 4) return -1;
  print F ("\r\n");
  char c;
  while (read(standard in FILENO, &c, 1) == 1) {
    if (iscntrl(c)) {
      print F ("%d\r\n", c);
    } else {
      print F ("%d ('%c')\r\n", c, c);
    }
  }
  editorReadKey();
  return -1;
}
int getWindowSize(int *rows, int *cols) {
  struct winsize ws;
  if (1 || ioctl(standard out FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws col == 0) {
    if (write(standard out FILENO, "\x1b[999C\x1b[999B", 12) != 12) return -1;
    return getCursorPosition(rows, cols);
  } else {
    *cols = ws.ws col;
    *rows = ws.ws row;
    return 0;
  }
}




The reply is an escape sequence! It’s an escape character (27), followed by a [ character, and then the actual response: 24;80R, or similar. (This escape sequence is documented as Cursor Position Report.)

As before, we’ve inserted a temporary call to editorReadKey() to let us observe our debug output before the screen gets cleared on exit.

(Note: If you’re using Bash on Windows, read() doesn’t time out so you’ll be stuck in an infinite loop. You’ll have to kill the process externally, or exit and reopen the command prompt window.)

We’re going to have to parse this response. But first, let’s read it into a buffer. We’ll keep reading characters until we get to the R character.

int getCursorPosition(int *rows, int *cols) {
  char buf[32];
  unsigned int i = 0;
  if (write(standard out FILENO, "\x1b[6n", 4) != 4) return -1;
  while (i < sizeof(buf) - 1) {
    if (read(standard in FILENO, &buf[i], 1) != 1) break;
    if (buf[i] == 'R') break;
    i++;
  }
  buf[i] = '\0';
  print F ("\r\n&buf[1]: '%s'\r\n", &buf[1]);
  editorReadKey();
  return -1;
}

When we print out the buffer, we don’t want to print the '\x1b' character, because the terminal would interpret it as an escape sequence and wouldn’t display it. So we skip the first character in buf by passing &buf[1] to print F (). print F () expects strings to end with a 0 byte, so we make sure to assign '\0' to the final byte of buf.

If you run the program, you’ll see we have the response in buf in the form of <esc>[24;80. Let’s parse the two numbers out of there using sscanf():

int getCursorPosition(int *rows, int *cols) {
  char buf[32];
  unsigned int i = 0;
  if (write(standard out FILENO, "\x1b[6n", 4) != 4) return -1;
  while (i < sizeof(buf) - 1) {
    if (read(standard in FILENO, &buf[i], 1) != 1) break;
    if (buf[i] == 'R') break;
    i++;
  }
  buf[i] = '\0';
  if (buf[0] != '\x1b' || buf[1] != '[') return -1;
  if (sscanf(&buf[2], "%d;%d", rows, cols) != 2) return -1;

sscanf() comes from standard I O dot H.

First we make sure it responded with an escape sequence. Then we pass a pointer to the third character of buf to sscanf(), skipping the '\x1b' and '[' characters. So we are passing a string of the form 24;80 to sscanf(). We are also passing it the string %d;%d which tells it to parse two integers separated by a ;, and put the values into the rows and cols variables.

Our fallback method for getting the window size is now complete. You should see that editorDrawRows() prints the correct number of tildes for the height of your terminal.

Now that we know that works, let’s remove the 1 || we put in the if condition temporarily.

int getWindowSize(int *rows, int *cols) {
  struct winsize ws;
  if (ioctl(standard out FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws col == 0) {
    if (write(standard out FILENO, "\x1b[999C\x1b[999B", 12) != 12) return -1;
    return getCursorPosition(rows, cols);
  } else {
    *cols = ws.ws col;
    *rows = ws.ws row;
    return 0;
  }
}

The last line. Maybe you noticed the last line of the screen doesn’t seem to have a tilde. That’s because of a small bug in our code. When we print the final tilde, we then print a "\r\n" like on any other line, but this causes the terminal to scroll in order to make room for a new, blank line. Let’s make the last line an exception when we print our "\r\n"’s.

void editorDrawRows() {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    write(standard out FILENO, "~", 1);
    if (y < E.screenrows - 1) {
      write(standard out FILENO, "\r\n", 2);
    }
  }
}

Append buffer. It’s not a good idea to make a whole bunch of small write()’s every time we refresh the screen. It would be better to do one big write(), to make sure the whole screen updates at once. Otherwise there could be small unpredictable pauses between write()’s, which would cause an annoying flicker effect.

We want to replace all our write() calls with code that appends the string to a buffer, and then write() this buffer out at the end. Unfortunately, C doesn’t have dynamic strings, so we’ll create our own dynamic string type that supports one operation: appending.

Let’s start by making a new  section, and defining the abuf struct under it.

struct abuf {
  char *b;
  int len;
};
define ABUF INIT {NULL, 0}

An append buffer consists of a pointer to our buffer in memory, and a length. We define an ABUF INIT constant which represents an empty buffer. This acts as a constructor for our abuf type.

Next, let’s define the abAppend() operation, as well as the abFree() destructor.





include string.h.




struct abuf { … };
define ABUF INIT {NULL, 0}
void abAppend(struct abuf *ab, const char *s, int len) {
  char *new = realloc(ab->b, ab->len + len);
  if (new == NULL) return;
  memcpy(&new[ab->len], s, len);
  ab->b = new;
  ab->len += len;
}
void abFree(struct abuf *ab) {
  free(ab->b);
}

realloc() and free() come from standard lib.h. memcpy() comes from string.h.

To append a string s to an abuf, the first thing we do is make sure we allocate enough memory to hold the new string. We ask realloc() to give us a block of memory that is the size of the current string plus the size of the string we are appending. realloc() will either extend the size of the block of memory we already have allocated, or it will take care of free()ing the current block of memory and allocating a new block of memory somewhere else that is big enough for our new string.

Then we use memcpy() to copy the string s after the end of the current data in the buffer, and we update the pointer and length of the abuf to the new values.

abFree() is a destructor that deallocates the dynamic memory used by an abuf.

Okay, our abuf type is ready to be put to use.

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    abAppend(ab, "~", 1);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() {
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[2J", 4);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  abAppend(&ab, "\x1b[H", 3);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}

In editorRefreshScreen(), we first initialize a new abuf called ab, by assigning ABUF INIT to it. We then replace each occurrence of write(standard out FILENO, ..) with abAppend(&ab, ..). We also pass ab into editorDrawRows(), so it too can use abAppend(). Lastly, we write() the buffer’s contents out to standard output, and free the memory used by the abuf.

Hide the cursor when repainting. There is another possible source of the annoying flicker effect we will take care of now. It’s possible that the cursor might be displayed in the middle of the screen somewhere for a split second while the terminal is drawing to the screen. To make sure that doesn’t happen, let’s hide the cursor before refreshing the screen, and show it again immediately after the refresh finishes.

void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() {
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[2J", 4);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  abAppend(&ab, "\x1b[H", 3);
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}

We use escape sequences to tell the terminal to hide and show the cursor. The h and l commands (Set Mode, Reset Mode) are used to turn on and turn off various terminal features or “modes”. The VT100 User Guide just linked to doesn’t document argument ?25 which we use above. It appears the cursor hiding/showing feature appeared in later VT models. So some terminals might not support hiding/showing the cursor, but if they don’t, then they will just ignore those escape sequences, which isn’t a big deal in this case.

Clear lines one at a time. Instead of clearing the entire screen before each refresh, it seems more optimal to clear each line as we redraw them. Let’s remove the <esc>[2J (clear entire screen) escape sequence, and instead put a <esc>[K sequence at the end of each line we draw.

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    abAppend(ab, "~", 1);
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() {
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[2J", 4);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  abAppend(&ab, "\x1b[H", 3);
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}

The K command (Erase In Line) erases part of the current line. Its argument is analogous to the J command’s argument: 2 erases the whole line, 1 erases the part of the line to the left of the cursor, and 0 erases the part of the line to the right of the cursor. 0 is the default argument, and that’s what we want, so we leave out the argument and just use <esc>[K.

It’s time to display a welcome message. Let’s display the name of our editor and a version number a third of the way down the screen.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    if (y == E.screenrows / 3) {
      char welcome[80];
      int welcomelen = snprint F (welcome, sizeof(welcome),
        "Kilo editor -- version %s", KILO VERSION);
      if (welcomelen > E.screencols) welcomelen = E.screencols;
      abAppend(ab, welcome, welcomelen);
    } else {
      abAppend(ab, "~", 1);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }

snprint F () comes from standard I O dot H.

We use the welcome buffer and snprint F () to interpolate our KILO VERSION string into the welcome message. We also truncate the length of the string in case the terminal is too tiny to fit our welcome message.

Now let’s center it.

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    if (y == E.screenrows / 3) {
      char welcome[80];
      int welcomelen = snprint F (welcome, sizeof(welcome),
        "Kilo editor -- version %s", KILO VERSION);
      if (welcomelen > E.screencols) welcomelen = E.screencols;
      int padding = (E.screencols - welcomelen) / 2;
      if (padding) {
        abAppend(ab, "~", 1);
        padding--;
      }
      while (padding--) abAppend(ab, " ", 1);
      abAppend(ab, welcome, welcomelen);
    } else {
      abAppend(ab, "~", 1);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }

To center a string, you divide the screen width by 2, and then subtract half of the string’s length from that. In other words: E.screencols/2 - welcomelen/2, which simplifies to (E.screencols - welcomelen) / 2. That tells you how far from the left edge of the screen you should start printing the string. So we fill that space with space characters, except for the first character, which should be a tilde.

Move the cursor. Let’s focus on input now. We want the user to be able to move the cursor around. The first step is to keep track of the cursor’s x and y position in the global editor state.

struct editorConfig {
  int cx, cy;
  int screenrows;
  int screencols;
  struct termios orig termios;
};
struct editorConfig E;

void initEditor() {
  E.cx = 0;
  E.cy = 0;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
int main() { … }

E.cx is the horizontal coordinate of the cursor (the column) and E.cy is the vertical coordinate (the row). We initialize both of them to 0, as we want the cursor to start at the top-left of the screen. (Since the C language uses indexes that start from 0, we will use 0-indexed values wherever possible.)

Now let’s add code to editorRefreshScreen() to move the cursor to the position stored in E.cx and E.cy.

void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() {
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  char buf[32];
  snprint F (buf, sizeof(buf), "\x1b[%d;%dH", E.cy + 1, E.cx + 1);
  abAppend(&ab, buf, strlen(buf));
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}

strlen() comes from string.h.

We changed the old H command into an H command with arguments, specifying the exact position we want the cursor to move to. (Make sure you deleted the old H command, as the above diff makes that easy to miss.)

We add 1 to E.cy and E.cx to convert from 0-indexed values to the 1-indexed values that the terminal uses.

At this point, you could try initializing E.cx to 10 or something, or insert E.cx++ into the main loop, to confirm that the code works as intended so far.

Next, we’ll allow the user to move the cursor using the wasd keys. (If you’re unfamiliar with using these keys as arrow keys: w is your up arrow, s is your down arrow, a is left, d is right.)

void editorMoveCursor(char key) {
  switch (key) {
    case 'a':
      E.cx--;
      break;
    case 'd':
      E.cx++;
      break;
    case 'w':
      E.cy--;
      break;
    case 's':
      E.cy++;
      break;
  }
}
void editorProcessKeypress() {
  char c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case 'w':
    case 's':
    case 'a':
    case 'd':
      editorMoveCursor(c);
      break;
  }
}


Now you should be able to move the cursor around with those keys.
Now that we have a way of mapping keypresses to move the cursor, let’s replace the wasd keys with the arrow keys. Last chapter we saw that pressing an arrow key sends multiple bytes as input to our program. These bytes are in the form of an escape sequence that starts with '\x1b', '[', followed by an 'A', 'B', 'C', or 'D' depending on which of the four arrow keys was pressed. Let’s modify editorReadKey() to read escape sequences of this form as a single keypress.

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      switch (seq[1]) {
        case 'A': return 'w';
        case 'B': return 's';
        case 'C': return 'd';
        case 'D': return 'a';
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }

If we read an escape character, we immediately read two more bytes into the seq buffer. If either of these reads time out (after 0.1 seconds), then we assume the user just pressed the Escape key and return that. Otherwise we look to see if the escape sequence is an arrow key escape sequence. If it is, we just return the corresponding wasd character, for now. If it’s not an escape sequence we recognize, we just return the escape character.

We make the seq buffer 3 bytes long because we will be handling longer escape sequences in the future.

We have basically aliased the arrow keys to the wasd keys. This gets the arrow keys working immediately, but leaves the wasd keys still mapped to the editorMoveCursor() function. What we want is for editorReadKey() to return special values for each arrow key that let us identify that a particular arrow key was pressed.

Let’s start by replacing each instance of the wasd characters with the constants ARROW UP, ARROW LEFT, ARROW DOWN, and ARROW RIGHT.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  ARROW LEFT = 'a',
  ARROW RIGHT = 'd',
  ARROW UP = 'w',
  ARROW DOWN = 's'
};


void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      switch (seq[1]) {
        case 'A': return ARROW UP;
        case 'B': return ARROW DOWN;
        case 'C': return ARROW RIGHT;
        case 'D': return ARROW LEFT;
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }

void editorMoveCursor(char key) {
  switch (key) {
    case ARROW LEFT:
      E.cx--;
      break;
    case ARROW RIGHT:
      E.cx++;
      break;
    case ARROW UP:
      E.cy--;
      break;
    case ARROW DOWN:
      E.cy++;
      break;
  }
}
void editorProcessKeypress() {
  char c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
  }
}


Now we just have to choose a representation for arrow keys that doesn’t conflict with wasd, in the editorKey enum. We will give them a large integer value that is out of the range of a char, so that they don’t conflict with any ordinary keypresses. We will also have to change all variables that store keypresses to be of type int instead of char.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  ARROW LEFT = 1000,
  ARROW RIGHT,
  ARROW UP,
  ARROW DOWN
};


void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      switch (seq[1]) {
        case 'A': return ARROW UP;
        case 'B': return ARROW DOWN;
        case 'C': return ARROW RIGHT;
        case 'D': return ARROW LEFT;
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }



void editorMoveCursor(int key) {
  switch (key) {
    case ARROW LEFT:
      E.cx--;
      break;
    case ARROW RIGHT:
      E.cx++;
      break;
    case ARROW UP:
      E.cy--;
      break;
    case ARROW DOWN:
      E.cy++;
      break;
  }
}
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
  }
}


By setting the first constant in the enum to 1000, the rest of the constants get incrementing values of 1001, 1002, 1003, and so on.

That concludes our arrow key handling code. At this point, it can be fun to try entering an escape sequence manually while the program runs. Try pressing the Escape key, the [ key, and Shift+C in sequence really fast, and you may see your keypresses being interpreted as the right arrow key being pressed. You have to be pretty fast to do it, so you may want to adjust the VTIME value in enableRawMode() temporarily, to make it easier. (It also helps to know that pressing Ctrl-[ is the same as pressing the Escape key, for the same reason that Ctrl-M is the same as pressing Enter: Ctrl clears the 6th and 7th bits of the character you type in combination with it.)

Prevent moving the cursor off screen. Currently, you can cause the E.cx and E.cy values to go into the negatives, or go past the right and bottom edges of the screen. Let’s prevent that by doing some bounds checking in editorMoveCursor().

void editorMoveCursor(int key) {
  switch (key) {
    case ARROW LEFT:
      if (E.cx != 0) {
        E.cx--;
      }
      break;
    case ARROW RIGHT:
      if (E.cx != E.screencols - 1) {
        E.cx++;
      }
      break;
    case ARROW UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW DOWN:
      if (E.cy != E.screenrows - 1) {
        E.cy++;
      }
      break;
  }
}
void editorProcessKeypress() { … }

To complete our low-level terminal code, we need to detect a few more special keypresses that use escape sequences, like the arrow keys did. We’ll start with the Page Up and Page Down keys. Page Up is sent as <esc>[5~ and Page Down is sent as <esc>[6~.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  ARROW LEFT = 1000,
  ARROW RIGHT,
  ARROW UP,
  ARROW DOWN,
  PAGE UP,
  PAGE DOWN
};

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      if (seq[1] >= '0' && seq[1] <= '9') {
        if (read(standard in FILENO, &seq[2], 1) != 1) return '\x1b';
        if (seq[2] == '~') {
          switch (seq[1]) {
            case '5': return PAGE UP;
            case '6': return PAGE DOWN;
          }
        }
      } else {
        switch (seq[1]) {
          case 'A': return ARROW UP;
          case 'B': return ARROW DOWN;
          case 'C': return ARROW RIGHT;
          case 'D': return ARROW LEFT;
        }
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }

Now you see why we declared seq to be able to store 3 bytes. If the byte after [ is a digit, we read another byte expecting it to be a ~. Then we test the digit byte to see if it’s a 5 or a 6.

Let’s make Page Up and Page Down do something. For now, we’ll have them move the cursor to the top of the screen or the bottom of the screen.

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
  }
}


We create a code block with that pair of braces so that we’re allowed to declare the times variable. (You can’t declare variables directly inside a switch statement.) We simulate the user pressing the ↑ or ↓ keys enough times to move to the top or bottom of the screen. Implementing Page Up and Page Down in this way will make it a lot easier for us later, when we implement scrolling.

If you’re on a laptop with an Fn key, you may be able to press Fn+↑ and Fn+↓ to simulate pressing the Page Up and Page Down keys.

The Home and End keys
Now let’s implement the Home and End keys. Like the previous keys, these keys also send escape sequences. Unlike the previous keys, there are many different escape sequences that could be sent by these keys, depending on your OS, or your terminal emulator. The Home key could be sent as <esc>[1~, <esc>[7~, <esc>[H, or <esc>OH. Similarly, the End key could be sent as <esc>[4~, <esc>[8~, <esc>[F, or <esc>OF. Let’s handle all of these cases.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  ARROW LEFT = 1000,
  ARROW RIGHT,
  ARROW UP,
  ARROW DOWN,
  HOME KEY,
  END KEY,
  PAGE UP,
  PAGE DOWN
};


void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      if (seq[1] >= '0' && seq[1] <= '9') {
        if (read(standard in FILENO, &seq[2], 1) != 1) return '\x1b';
        if (seq[2] == '~') {
          switch (seq[1]) {
            case '1': return HOME KEY;
            case '4': return END KEY;
            case '5': return PAGE UP;
            case '6': return PAGE DOWN;
            case '7': return HOME KEY;
            case '8': return END KEY;
          }
        }
      } else {
        switch (seq[1]) {
          case 'A': return ARROW UP;
          case 'B': return ARROW DOWN;
          case 'C': return ARROW RIGHT;
          case 'D': return ARROW LEFT;
          case 'H': return HOME KEY;
          case 'F': return END KEY;
        }
      }
    } else if (seq[0] == 'O') {
      switch (seq[1]) {
        case 'H': return HOME KEY;
        case 'F': return END KEY;
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }

Now let’s make Home and End do something. For now, we’ll have them move the cursor to the left or right edges of the screen.

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      E.cx = E.screencols - 1;
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
  }
}


If you’re on a laptop with an Fn key, you may be able to press Fn+← and Fn+→ to simulate pressing the Home and End keys.

Lastly, let’s detect when the Delete key is pressed. It simply sends the escape sequence <esc>[3~, so it’s easy to add to our switch statement. We won’t make this key do anything for now.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  ARROW LEFT = 1000,
  ARROW RIGHT,
  ARROW UP,
  ARROW DOWN,
  DEL KEY,
  HOME KEY,
  END KEY,
  PAGE UP,
  PAGE DOWN
};


void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      if (seq[1] >= '0' && seq[1] <= '9') {
        if (read(standard in FILENO, &seq[2], 1) != 1) return '\x1b';
        if (seq[2] == '~') {
          switch (seq[1]) {
            case '1': return HOME KEY;
            case '3': return DEL KEY;
            case '4': return END KEY;
            case '5': return PAGE UP;
            case '6': return PAGE DOWN;
            case '7': return HOME KEY;
            case '8': return END KEY;
          }
        }
      } else {
        switch (seq[1]) {
          case 'A': return ARROW UP;
          case 'B': return ARROW DOWN;
          case 'C': return ARROW RIGHT;
          case 'D': return ARROW LEFT;
          case 'H': return HOME KEY;
          case 'F': return END KEY;
        }
      }
    } else if (seq[0] == 'O') {
      switch (seq[1]) {
        case 'H': return HOME KEY;
        case 'F': return END KEY;
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }

If you’re on a laptop with an Fn key, you may be able to press Fn+Backspace to simulate pressing the Delete key.

Next we will get our program to display text files, complete with vertical and horizontal scrolling and a status bar.

Raw input and output. Press Ctrl-Q to quit.
Last chapter we saw that the Ctrl key combined with the alphabetic keys seemed to map to bytes 1–26. We can use this to detect Ctrl key combinations and map them to different operations in our editor. We’ll start by mapping Ctrl-Q to the quit operation.








define CTRL KEY(k) ((k) & 0x1f)

int main() {
  enableRawMode();
  while (1) {
    char c = '\0';
    if (read(standard in FILENO, &c, 1) == -1 && errno != EAGAIN) die("read");
    if (iscntrl(c)) {
      print F ("%d\r\n", c);
    } else {
      print F ("%d ('%c')\r\n", c, c);
    }
    if (c == CTRL KEY('q')) break;
  }
  

The CTRL KEY macro bitwise-ANDs a character with the value 00011111, in binary. (In C, you generally specify bitmasks using hexadecimal, since C doesn’t have binary literals, and hexadecimal is more concise and readable once you get used to it.) In other words, it sets the upper 3 bits of the character to 0. This mirrors what the Ctrl key does in the terminal: it strips bits 5 and 6 from whatever key you press in combination with Ctrl, and sends that. (By convention, bit numbering starts from 0.) The ASCII character set seems to be designed this way on purpose. (It is also similarly designed so that you can set and clear bit 5 to switch between lowercase and uppercase.)

Refactor keyboard input
Let’s make a function for low-level keypress reading, and another function for mapping keypresses to editor operations. We’ll also stop printing out keypresses at this point.

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  return c;
}

void editorProcessKeypress() {
  char c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      exit(0);
      break;
  }
}

int main() {
  enableRawMode();
  while (1) {
    editorProcessKeypress();
  }
  

editorReadKey()’s job is to wait for one keypress, and return it. Later, we’ll expand this function to handle escape sequences, which involves reading multiple bytes that represent a single keypress, as is the case with the arrow keys.

editorProcessKeypress() waits for a keypress, and then handles it. Later, it will map various Ctrl key combinations and other special keys to different editor functions, and insert any alphanumeric and other printable keys’ characters into the text that is being edited.

Note that editorReadKey() belongs in the  section because it deals with low-level terminal input, whereas editorProcessKeypress() belongs in the new  section because it deals with mapping keys to editor functions at a much higher level.

Now we have vastly simplified main(), and we will try to keep it that way.

We’re going to render the editor’s user interface to the screen after each keypress. Let’s start by just clearing the screen.

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() { … }

void editorRefreshScreen() {
  write(standard out FILENO, "\x1b[2J", 4);
}

int main() {
  enableRawMode();
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }
  

write() and standard out FILENO come from unistd.h.

The 4 in our write() call means we are writing 4 bytes out to the terminal. The first byte is \x1b, which is the escape character, or 27 in decimal. (Try and remember \x1b, we will be using it a lot.) The other three bytes are [2J.

We are writing an escape sequence to the terminal. Escape sequences always start with an escape character (27) followed by a [ character. Escape sequences instruct the terminal to do various text formatting tasks, such as coloring text, moving the cursor around, and clearing parts of the screen.

We are using the J command (Erase In Display) to clear the screen. Escape sequence commands take arguments, which come before the command. In this case the argument is 2, which says to clear the entire screen. <esc>[1J would clear the screen up to where the cursor is, and <esc>[0J would clear the screen from the cursor up to the end of the screen. Also, 0 is the default argument for J, so just <esc>[J by itself would also clear the screen from the cursor to the end.

For our text editor, we will be mostly using VT100 escape sequences, which are supported very widely by modern terminal emulators. See the VT100 User Guide for complete documentation of each escape sequence.

If we wanted to support the maximum number of terminals out there, we could use the ncurses library, which uses the terminfo database to figure out the capabilities of a terminal and what escape sequences to use for that particular terminal.

You may notice that the <esc>[2J command left the cursor at the bottom of the screen. Let’s reposition it at the top-left corner so that we’re ready to draw the editor interface from top to bottom.

void editorRefreshScreen() {
  write(standard out FILENO, "\x1b[2J", 4);
  write(standard out FILENO, "\x1b[H", 3);
}

This escape sequence is only 3 bytes long, and uses the H command (Cursor Position) to position the cursor. The H command actually takes two arguments: the row number and the column number at which to position the cursor. So if you have an 80×24 size terminal and you want the cursor in the center of the screen, you could use the command <esc>[12;40H. (Multiple arguments are separated by a ; character.) The default arguments for H both happen to be 1, so we can leave both arguments out and it will position the cursor at the first row and first column, as if we had sent the <esc>[1;1H command. (Rows and columns are numbered starting at 1, not 0.)

Let’s clear the screen and reposition the cursor when our program exits. If an error occurs in the middle of rendering the screen, we don’t want a bunch of garbage left over on the screen, and we don’t want the error to be printed wherever the cursor happens to be at that point.

void die(const char *s) {
  write(standard out FILENO, "\x1b[2J", 4);
  write(standard out FILENO, "\x1b[H", 3);
  perror(s);
  exit(1);
}
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() { … }


void editorProcessKeypress() {
  char c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
  }
}

We have two exit points we want to clear the screen at: die(), and when the user presses Ctrl-Q to quit.

We could use atexit() to clear the screen when our program exits, but then the error message printed by die() would get erased right after printing it.

It’s time to start drawing. Let’s draw a column of tildes (~) on the left hand side of the screen, like vim does. In our text editor, we’ll draw a tilde at the beginning of any lines that come after the end of the file being edited.

void editorDrawRows() {
  int y;
  for (y = 0; y < 24; y++) {
    write(standard out FILENO, "~\r\n", 3);
  }
}
void editorRefreshScreen() {
  write(standard out FILENO, "\x1b[2J", 4);
  write(standard out FILENO, "\x1b[H", 3);
  editorDrawRows();
  write(standard out FILENO, "\x1b[H", 3);
}

editorDrawRows() will handle drawing each row of the buffer of text being edited. For now it draws a tilde in each row, which means that row is not part of the file and can’t contain any text.

We don’t know the size of the terminal yet, so we don’t know how many rows to draw. For now we just draw 24 rows.

After we’re done drawing, we do another <esc>[H escape sequence to reposition the cursor back up at the top-left corner.

Global state
Our next goal is to get the size of the terminal, so we know how many rows to draw in editorDrawRows(). But first, let’s set up a global struct that will contain our editor state, which we’ll use to store the width and height of the terminal. For now, let’s just put our orig termios global into the struct.

struct editorConfig {
  struct termios orig termios;
};
struct editorConfig E;

void die(const char *s) { … }
void disableRawMode() {
  if (tcsetattr(standard in FILENO, TCSAFLUSH, &E.orig termios) == -1)
    die("tcsetattr");
}
void enableRawMode() {
  if (tcgetattr(standard in FILENO, &E.orig termios) == -1) die("tcgetattr");
  atexit(disableRawMode);
  struct termios raw = E.orig termios;
  raw.c iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  raw.c oflag &= ~(OPOST);
  raw.c cflag |= (CS8);
  raw.c lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  raw.c cc[VMIN] = 0;
  raw.c cc[VTIME] = 1;
  if (tcsetattr(standard in FILENO, TCSAFLUSH, &raw) == -1) die("tcsetattr");
}
char editorReadKey() { … }

Our global variable containing our editor state is named E. We must replace all occurrences of orig termios with E.orig termios.

Window size, the easy way
On most systems, you should be able to get the size of the terminal by simply calling ioctl() with the TIOCGWINSZ request. (As far as I can tell, it stands for Terminal IOCtl (which itself stands for Input/Output Control) Get WINdow SiZe.)









void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() { … }
int getWindowSize(int *rows, int *cols) {
  struct winsize ws;
  if (ioctl(standard out FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws col == 0) {
    return -1;
  } else {
    *cols = ws.ws col;
    *rows = ws.ws row;
    return 0;
  }
}

ioctl(), TIOCGWINSZ, and struct winsize come from <sys/ioctl.h.

On success, ioctl() will place the number of columns wide and the number of rows high the terminal is into the given winsize struct. On failure, ioctl() returns -1. We also check to make sure the values it gave back weren’t 0, because apparently that’s a possible erroneous outcome. If ioctl() failed in either way, we have getWindowSize() report failure by returning -1. If it succeeded, we pass the values back by setting the int references that were passed to the function. (This is a common approach to having functions return multiple values in C. It also allows you to use the return value to indicate success or failure.)

Now let’s add screenrows and screencols to our global editor state, and call getWindowSize() to fill in those values.

struct editorConfig {
  int screenrows;
  int screencols;
  struct termios orig termios;
};
struct editorConfig E;

void initEditor() {
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
int main() {
  enableRawMode();
  initEditor();
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }
  

initEditor()’s job will be to initialize all the fields in the E struct.

Now we’re ready to display the proper number of tildes on the screen:

void editorDrawRows() {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    write(standard out FILENO, "~\r\n", 3);
  }
}
void editorRefreshScreen() { … }

Window size, the hard way. ioctl() isn’t guaranteed to be able to request the window size on all systems, so we are going to provide a fallback method of getting the window size.

The strategy is to position the cursor at the bottom-right of the screen, then use escape sequences that let us query the position of the cursor. That tells us how many rows and columns there must be on the screen.

Let’s start by moving the cursor to the bottom-right.

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() { … }
int getWindowSize(int *rows, int *cols) {
  struct winsize ws;
  if (1 || ioctl(standard out FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws col == 0) {
    if (write(standard out FILENO, "\x1b[999C\x1b[999B", 12) != 12) return -1;
    editorReadKey();
    return -1;
  } else {
    *cols = ws.ws col;
    *rows = ws.ws row;
    return 0;
  }
}

As you might have gathered from the code, there is no simple “move the cursor to the bottom-right corner” command.

We are sending two escape sequences one after the other. The C command (Cursor Forward) moves the cursor to the right, and the B command (Cursor Down) moves the cursor down. The argument says how much to move it right or down by. We use a very large value, 999, which should ensure that the cursor reaches the right and bottom edges of the screen.

The C and B commands are specifically documented to stop the cursor from going past the edge of the screen. The reason we don’t use the <esc>[999;999H command is that the documentation doesn’t specify what happens when you try to move the cursor off-screen.

Note that we are sticking a 1 || at the front of our if condition temporarily, so that we can test this fallback branch we are developing.

Because we’re always returning -1 (meaning an error occurred) from getWindowSize() at this point, we make a call to editorReadKey() so we can observe the results of our escape sequences before the program calls die() and clears the screen. When you run the program, you should see the cursor is positioned at the bottom-right corner of the screen, and then when you press a key you’ll see the error message printed by die() after it clears the screen.

Next we need to get the cursor position. The n command (Device Status Report) can be used to query the terminal for status information. We want to give it an argument of 6 to ask for the cursor position. Then we can read the reply from the standard input. Let’s print out each character from the standard input to see what the reply looks like.

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() { … }
int getCursorPosition(int *rows, int *cols) {
  if (write(standard out FILENO, "\x1b[6n", 4) != 4) return -1;
  print F ("\r\n");
  char c;
  while (read(standard in FILENO, &c, 1) == 1) {
    if (iscntrl(c)) {
      print F ("%d\r\n", c);
    } else {
      print F ("%d ('%c')\r\n", c, c);
    }
  }
  editorReadKey();
  return -1;
}
int getWindowSize(int *rows, int *cols) {
  struct winsize ws;
  if (1 || ioctl(standard out FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws col == 0) {
    if (write(standard out FILENO, "\x1b[999C\x1b[999B", 12) != 12) return -1;
    return getCursorPosition(rows, cols);
  } else {
    *cols = ws.ws col;
    *rows = ws.ws row;
    return 0;
  }
}

The reply is an escape sequence! It’s an escape character (27), followed by a [ character, and then the actual response: 24;80R, or similar. (This escape sequence is documented as Cursor Position Report.)

As before, we’ve inserted a temporary call to editorReadKey() to let us observe our debug output before the screen gets cleared on exit.

(Note: If you’re using Bash on Windows, read() doesn’t time out so you’ll be stuck in an infinite loop. You’ll have to kill the process externally, or exit and reopen the command prompt window.)

We’re going to have to parse this response. But first, let’s read it into a buffer. We’ll keep reading characters until we get to the R character.

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() { … }
int getCursorPosition(int *rows, int *cols) {
  char buf[32];
  unsigned int i = 0;
  if (write(standard out FILENO, "\x1b[6n", 4) != 4) return -1;
  while (i < sizeof(buf) - 1) {
    if (read(standard in FILENO, &buf[i], 1) != 1) break;
    if (buf[i] == 'R') break;
    i++;
  }
  buf[i] = '\0';
  print F ("\r\n&buf[1]: '%s'\r\n", &buf[1]);
  editorReadKey();
  return -1;
}
int getWindowSize(int *rows, int *cols) { … }

When we print out the buffer, we don’t want to print the '\x1b' character, because the terminal would interpret it as an escape sequence and wouldn’t display it. So we skip the first character in buf by passing &buf[1] to print F (). print F () expects strings to end with a 0 byte, so we make sure to assign '\0' to the final byte of buf.

If you run the program, you’ll see we have the response in buf in the form of <esc>[24;80. Let’s parse the two numbers out of there using sscanf():

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() { … }
int getCursorPosition(int *rows, int *cols) {
  char buf[32];
  unsigned int i = 0;
  if (write(standard out FILENO, "\x1b[6n", 4) != 4) return -1;
  while (i < sizeof(buf) - 1) {
    if (read(standard in FILENO, &buf[i], 1) != 1) break;
    if (buf[i] == 'R') break;
    i++;
  }
  buf[i] = '\0';
  if (buf[0] != '\x1b' || buf[1] != '[') return -1;
  if (sscanf(&buf[2], "%d;%d", rows, cols) != 2) return -1;
  
int getWindowSize(int *rows, int *cols) { … }

sscanf() comes from standard I O dot H.

First we make sure it responded with an escape sequence. Then we pass a pointer to the third character of buf to sscanf(), skipping the '\x1b' and '[' characters. So we are passing a string of the form 24;80 to sscanf(). We are also passing it the string %d;%d which tells it to parse two integers separated by a ;, and put the values into the rows and cols variables.

Our fallback method for getting the window size is now complete. You should see that editorDrawRows() prints the correct number of tildes for the height of your terminal.

Now that we know that works, let’s remove the 1 || we put in the if condition temporarily.

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() { … }
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) {
  struct winsize ws;
  if (ioctl(standard out FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws col == 0) {
    if (write(standard out FILENO, "\x1b[999C\x1b[999B", 12) != 12) return -1;
    return getCursorPosition(rows, cols);
  } else {
    *cols = ws.ws col;
    *rows = ws.ws row;
    return 0;
  }
}

The last line of the screen doesn’t seem to have a tilde. That’s because of a small bug in our code. When we print the final tilde, we then print a "\r\n" like on any other line, but this causes the terminal to scroll in order to make room for a new, blank line. Let’s make the last line an exception when we print our "\r\n"’s.

void editorDrawRows() {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    write(standard out FILENO, "~", 1);
    if (y < E.screenrows - 1) {
      write(standard out FILENO, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }

It’s not a good idea to make a whole bunch of small write()’s every time we refresh the screen. It would be better to do one big write(), to make sure the whole screen updates at once. Otherwise there could be small unpredictable pauses between write()’s, which would cause an annoying flicker effect.

We want to replace all our write() calls with code that appends the string to a buffer, and then write() this buffer out at the end. Unfortunately, C doesn’t have dynamic strings, so we’ll create our own dynamic string type that supports one operation: appending.

Let’s start by making a new  section, and defining the abuf struct under it.

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() { … }
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }

struct abuf {
  char *b;
  int len;
};
define ABUF INIT {NULL, 0}

An append buffer consists of a pointer to our buffer in memory, and a length. We define an ABUF INIT constant which represents an empty buffer. This acts as a constructor for our abuf type.

Next, let’s define the abAppend() operation, as well as the abFree() destructor.





include string.h.




struct abuf { … };
define ABUF INIT {NULL, 0}
void abAppend(struct abuf *ab, const char *s, int len) {
  char *new = realloc(ab->b, ab->len + len);
  if (new == NULL) return;
  memcpy(&new[ab->len], s, len);
  ab->b = new;
  ab->len += len;
}
void abFree(struct abuf *ab) {
  free(ab->b);
}

realloc() and free() come from standard lib.h. memcpy() comes from string.h.

To append a string s to an abuf, the first thing we do is make sure we allocate enough memory to hold the new string. We ask realloc() to give us a block of memory that is the size of the current string plus the size of the string we are appending. realloc() will either extend the size of the block of memory we already have allocated, or it will take care of free()ing the current block of memory and allocating a new block of memory somewhere else that is big enough for our new string.

Then we use memcpy() to copy the string s after the end of the current data in the buffer, and we update the pointer and length of the abuf to the new values.

abFree() is a destructor that deallocates the dynamic memory used by an abuf.

Okay, our abuf type is ready to be put to use.

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    abAppend(ab, "~", 1);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() {
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[2J", 4);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  abAppend(&ab, "\x1b[H", 3);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}



In editorRefreshScreen(), we first initialize a new abuf called ab, by assigning ABUF INIT to it. We then replace each occurrence of write(standard out FILENO, ..) with abAppend(&ab, ..). We also pass ab into editorDrawRows(), so it too can use abAppend(). Lastly, we write() the buffer’s contents out to standard output, and free the memory used by the abuf.

There is another possible source of the annoying flicker effect we will take care of now. It’s possible that the cursor might be displayed in the middle of the screen somewhere for a split second while the terminal is drawing to the screen. To make sure that doesn’t happen, let’s hide the cursor before refreshing the screen, and show it again immediately after the refresh finishes.

void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() {
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[2J", 4);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  abAppend(&ab, "\x1b[H", 3);
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}

We use escape sequences to tell the terminal to hide and show the cursor. The h and l commands (Set Mode, Reset Mode) are used to turn on and turn off various terminal features or “modes”. The VT100 User Guide just linked to doesn’t document argument ?25 which we use above. It appears the cursor hiding/showing feature appeared in later VT models. So some terminals might not support hiding/showing the cursor, but if they don’t, then they will just ignore those escape sequences, which isn’t a big deal in this case.

Instead of clearing the entire screen before each refresh, it seems more optimal to clear each line as we redraw them. Let’s remove the <esc>[2J (clear entire screen) escape sequence, and instead put a <esc>[K sequence at the end of each line we draw.

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    abAppend(ab, "~", 1);
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() {
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[2J", 4);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  abAppend(&ab, "\x1b[H", 3);
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}

The K command (Erase In Line) erases part of the current line. Its argument is analogous to the J command’s argument: 2 erases the whole line, 1 erases the part of the line to the left of the cursor, and 0 erases the part of the line to the right of the cursor. 0 is the default argument, and that’s what we want, so we leave out the argument and just use <esc>[K.

It’s time to display a welcome message. Let’s display the name of our editor and a version number a third of the way down the screen.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    if (y == E.screenrows / 3) {
      char welcome[80];
      int welcomelen = snprint F (welcome, sizeof(welcome),
        "Kilo editor -- version %s", KILO VERSION);
      if (welcomelen > E.screencols) welcomelen = E.screencols;
      abAppend(ab, welcome, welcomelen);
    } else {
      abAppend(ab, "~", 1);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }

snprint F () comes from standard I O dot H.

We use the welcome buffer and snprint F () to interpolate our KILO VERSION string into the welcome message. We also truncate the length of the string in case the terminal is too tiny to fit our welcome message.

Now let’s center it.

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    if (y == E.screenrows / 3) {
      char welcome[80];
      int welcomelen = snprint F (welcome, sizeof(welcome),
        "Kilo editor -- version %s", KILO VERSION);
      if (welcomelen > E.screencols) welcomelen = E.screencols;
      int padding = (E.screencols - welcomelen) / 2;
      if (padding) {
        abAppend(ab, "~", 1);
        padding--;
      }
      while (padding--) abAppend(ab, " ", 1);
      abAppend(ab, welcome, welcomelen);
    } else {
      abAppend(ab, "~", 1);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }

To center a string, you divide the screen width by 2, and then subtract half of the string’s length from that. In other words: E.screencols/2 - welcomelen/2, which simplifies to (E.screencols - welcomelen) / 2. That tells you how far from the left edge of the screen you should start printing the string. So we fill that space with space characters, except for the first character, which should be a tilde.

Let’s focus on input now. We want the user to be able to move the cursor around. The first step is to keep track of the cursor’s x and y position in the global editor state.

struct editorConfig {
  int cx, cy;
  int screenrows;
  int screencols;
  struct termios orig termios;
};
struct editorConfig E;

void initEditor() {
  E.cx = 0;
  E.cy = 0;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
int main() { … }

E.cx is the horizontal coordinate of the cursor (the column) and E.cy is the vertical coordinate (the row). We initialize both of them to 0, as we want the cursor to start at the top-left of the screen. (Since the C language uses indexes that start from 0, we will use 0-indexed values wherever possible.)

Now let’s add code to editorRefreshScreen() to move the cursor to the position stored in E.cx and E.cy.

void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() {
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  char buf[32];
  snprint F (buf, sizeof(buf), "\x1b[%d;%dH", E.cy + 1, E.cx + 1);
  abAppend(&ab, buf, strlen(buf));
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}

strlen() comes from string.h.

We changed the old H command into an H command with arguments, specifying the exact position we want the cursor to move to. (Make sure you deleted the old H command, as the above diff makes that easy to miss.)

We add 1 to E.cy and E.cx to convert from 0-indexed values to the 1-indexed values that the terminal uses.

At this point, you could try initializing E.cx to 10 or something, or insert E.cx++ into the main loop, to confirm that the code works as intended so far.

Next, we’ll allow the user to move the cursor using the wasd keys. (If you’re unfamiliar with using these keys as arrow keys: w is your up arrow, s is your down arrow, a is left, d is right.)

void editorMoveCursor(char key) {
  switch (key) {
    case 'a':
      E.cx--;
      break;
    case 'd':
      E.cx++;
      break;
    case 'w':
      E.cy--;
      break;
    case 's':
      E.cy++;
      break;
  }
}
void editorProcessKeypress() {
  char c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case 'w':
    case 's':
    case 'a':
    case 'd':
      editorMoveCursor(c);
      break;
  }
}


Now you should be able to move the cursor around with those keys.

Arrow keys
Now that we have a way of mapping keypresses to move the cursor, let’s replace the wasd keys with the arrow keys. Last chapter we saw that pressing an arrow key sends multiple bytes as input to our program. These bytes are in the form of an escape sequence that starts with '\x1b', '[', followed by an 'A', 'B', 'C', or 'D' depending on which of the four arrow keys was pressed. Let’s modify editorReadKey() to read escape sequences of this form as a single keypress.

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      switch (seq[1]) {
        case 'A': return 'w';
        case 'B': return 's';
        case 'C': return 'd';
        case 'D': return 'a';
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }





If we read an escape character, we immediately read two more bytes into the seq buffer. If either of these reads time out (after 0.1 seconds), then we assume the user just pressed the Escape key and return that. Otherwise we look to see if the escape sequence is an arrow key escape sequence. If it is, we just return the corresponding wasd character, for now. If it’s not an escape sequence we recognize, we just return the escape character.

We make the seq buffer 3 bytes long because we will be handling longer escape sequences in the future.

We have basically aliased the arrow keys to the wasd keys. This gets the arrow keys working immediately, but leaves the wasd keys still mapped to the editorMoveCursor() function. What we want is for editorReadKey() to return special values for each arrow key that let us identify that a particular arrow key was pressed.

Let’s start by replacing each instance of the wasd characters with the constants ARROW UP, ARROW LEFT, ARROW DOWN, and ARROW RIGHT.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  ARROW LEFT = 'a',
  ARROW RIGHT = 'd',
  ARROW UP = 'w',
  ARROW DOWN = 's'
};


void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
char editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      switch (seq[1]) {
        case 'A': return ARROW UP;
        case 'B': return ARROW DOWN;
        case 'C': return ARROW RIGHT;
        case 'D': return ARROW LEFT;
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }



void editorMoveCursor(char key) {
  switch (key) {
    case ARROW LEFT:
      E.cx--;
      break;
    case ARROW RIGHT:
      E.cx++;
      break;
    case ARROW UP:
      E.cy--;
      break;
    case ARROW DOWN:
      E.cy++;
      break;
  }
}
void editorProcessKeypress() {
  char c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
  }
}


Now we just have to choose a representation for arrow keys that doesn’t conflict with wasd, in the editorKey enum. We will give them a large integer value that is out of the range of a char, so that they don’t conflict with any ordinary keypresses. We will also have to change all variables that store keypresses to be of type int instead of char.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  ARROW LEFT = 1000,
  ARROW RIGHT,
  ARROW UP,
  ARROW DOWN
};


void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      switch (seq[1]) {
        case 'A': return ARROW UP;
        case 'B': return ARROW DOWN;
        case 'C': return ARROW RIGHT;
        case 'D': return ARROW LEFT;
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }



void editorMoveCursor(int key) {
  switch (key) {
    case ARROW LEFT:
      E.cx--;
      break;
    case ARROW RIGHT:
      E.cx++;
      break;
    case ARROW UP:
      E.cy--;
      break;
    case ARROW DOWN:
      E.cy++;
      break;
  }
}
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
  }
}


By setting the first constant in the enum to 1000, the rest of the constants get incrementing values of 1001, 1002, 1003, and so on.

That concludes our arrow key handling code. At this point, it can be fun to try entering an escape sequence manually while the program runs. Try pressing the Escape key, the [ key, and Shift+C in sequence really fast, and you may see your keypresses being interpreted as the right arrow key being pressed. You have to be pretty fast to do it, so you may want to adjust the VTIME value in enableRawMode() temporarily, to make it easier. (It also helps to know that pressing Ctrl-[ is the same as pressing the Escape key, for the same reason that Ctrl-M is the same as pressing Enter: Ctrl clears the 6th and 7th bits of the character you type in combination with it.)

Prevent moving the cursor off screen
Currently, you can cause the E.cx and E.cy values to go into the negatives, or go past the right and bottom edges of the screen. Let’s prevent that by doing some bounds checking in editorMoveCursor().

void editorMoveCursor(int key) {
  switch (key) {
    case ARROW LEFT:
      if (E.cx != 0) {
        E.cx--;
      }
      break;
    case ARROW RIGHT:
      if (E.cx != E.screencols - 1) {
        E.cx++;
      }
      break;
    case ARROW UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW DOWN:
      if (E.cy != E.screenrows - 1) {
        E.cy++;
      }
      break;
  }
}
void editorProcessKeypress() { … }


The Page Up and Page Down keys
To complete our low-level terminal code, we need to detect a few more special keypresses that use escape sequences, like the arrow keys did. We’ll start with the Page Up and Page Down keys. Page Up is sent as <esc>[5~ and Page Down is sent as <esc>[6~.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  ARROW LEFT = 1000,
  ARROW RIGHT,
  ARROW UP,
  ARROW DOWN,
  PAGE UP,
  PAGE DOWN
};

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      if (seq[1] >= '0' && seq[1] <= '9') {
        if (read(standard in FILENO, &seq[2], 1) != 1) return '\x1b';
        if (seq[2] == '~') {
          switch (seq[1]) {
            case '5': return PAGE UP;
            case '6': return PAGE DOWN;
          }
        }
      } else {
        switch (seq[1]) {
          case 'A': return ARROW UP;
          case 'B': return ARROW DOWN;
          case 'C': return ARROW RIGHT;
          case 'D': return ARROW LEFT;
        }
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }





Now you see why we declared seq to be able to store 3 bytes. If the byte after [ is a digit, we read another byte expecting it to be a ~. Then we test the digit byte to see if it’s a 5 or a 6.

Let’s make Page Up and Page Down do something. For now, we’ll have them move the cursor to the top of the screen or the bottom of the screen.

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
  }
}


We create a code block with that pair of braces so that we’re allowed to declare the times variable. (You can’t declare variables directly inside a switch statement.) We simulate the user pressing the ↑ or ↓ keys enough times to move to the top or bottom of the screen. Implementing Page Up and Page Down in this way will make it a lot easier for us later, when we implement scrolling.

If you’re on a laptop with an Fn key, you may be able to press Fn+↑ and Fn+↓ to simulate pressing the Page Up and Page Down keys.

The Home and End keys
Now let’s implement the Home and End keys. Like the previous keys, these keys also send escape sequences. Unlike the previous keys, there are many different escape sequences that could be sent by these keys, depending on your OS, or your terminal emulator. The Home key could be sent as <esc>[1~, <esc>[7~, <esc>[H, or <esc>OH. Similarly, the End key could be sent as <esc>[4~, <esc>[8~, <esc>[F, or <esc>OF. Let’s handle all of these cases.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  ARROW LEFT = 1000,
  ARROW RIGHT,
  ARROW UP,
  ARROW DOWN,
  HOME KEY,
  END KEY,
  PAGE UP,
  PAGE DOWN
};


void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      if (seq[1] >= '0' && seq[1] <= '9') {
        if (read(standard in FILENO, &seq[2], 1) != 1) return '\x1b';
        if (seq[2] == '~') {
          switch (seq[1]) {
            case '1': return HOME KEY;
            case '4': return END KEY;
            case '5': return PAGE UP;
            case '6': return PAGE DOWN;
            case '7': return HOME KEY;
            case '8': return END KEY;
          }
        }
      } else {
        switch (seq[1]) {
          case 'A': return ARROW UP;
          case 'B': return ARROW DOWN;
          case 'C': return ARROW RIGHT;
          case 'D': return ARROW LEFT;
          case 'H': return HOME KEY;
          case 'F': return END KEY;
        }
      }
    } else if (seq[0] == 'O') {
      switch (seq[1]) {
        case 'H': return HOME KEY;
        case 'F': return END KEY;
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }





Now let’s make Home and End do something. For now, we’ll have them move the cursor to the left or right edges of the screen.

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      E.cx = E.screencols - 1;
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
  }
}


If you’re on a laptop with an Fn key, you may be able to press Fn+← and Fn+→ to simulate pressing the Home and End keys.

The Delete key
Lastly, let’s detect when the Delete key is pressed. It simply sends the escape sequence <esc>[3~, so it’s easy to add to our switch statement. We won’t make this key do anything for now.

define KILO VERSION "0.0.1"
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  ARROW LEFT = 1000,
  ARROW RIGHT,
  ARROW UP,
  ARROW DOWN,
  DEL KEY,
  HOME KEY,
  END KEY,
  PAGE UP,
  PAGE DOWN
};


void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int editorReadKey() {
  int nread;
  char c;
  while ((nread = read(standard in FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  if (c == '\x1b') {
    char seq[3];
    if (read(standard in FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(standard in FILENO, &seq[1], 1) != 1) return '\x1b';
    if (seq[0] == '[') {
      if (seq[1] >= '0' && seq[1] <= '9') {
        if (read(standard in FILENO, &seq[2], 1) != 1) return '\x1b';
        if (seq[2] == '~') {
          switch (seq[1]) {
            case '1': return HOME KEY;
            case '3': return DEL KEY;
            case '4': return END KEY;
            case '5': return PAGE UP;
            case '6': return PAGE DOWN;
            case '7': return HOME KEY;
            case '8': return END KEY;
          }
        }
      } else {
        switch (seq[1]) {
          case 'A': return ARROW UP;
          case 'B': return ARROW DOWN;
          case 'C': return ARROW RIGHT;
          case 'D': return ARROW LEFT;
          case 'H': return HOME KEY;
          case 'F': return END KEY;
        }
      }
    } else if (seq[0] == 'O') {
      switch (seq[1]) {
        case 'H': return HOME KEY;
        case 'F': return END KEY;
      }
    }
    return '\x1b';
  } else {
    return c;
  }
}
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }





If you’re on a laptop with an Fn key, you may be able to press Fn+Backspace to simulate pressing the Delete key.

In the next chapter, we will get our program to display text files, complete with vertical and horizontal scrolling and a status bar.

A line viewer. Let’s create a data type for storing a row of text in our editor.

typedef struct erow {
  int size;
  char *chars;
} erow;
struct editorConfig {
  int cx, cy;
  int screenrows;
  int screencols;
  int numrows;
  erow row;
  struct termios orig termios;
};
struct editorConfig E;

void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.numrows = 0;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
int main() { … }

erow stands for “editor row”, and stores a line of text as a pointer to the dynamically-allocated character data and a length. The typedef lets us refer to the type as erow instead of struct erow.

We add an erow value to the editor global state, as well as a numrows variable. For now, the editor will only display a single line of text, and so numrows can be either 0 or 1. We initialize it to 0 in initEditor().

Let’s fill that erow with some text now. We won’t worry about reading from a file just yet. Instead, we’ll hardcode a “Hello, world” string into it.





include string.h.

include sys/types.h.





void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int editorReadKey() { … }
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }

void editorOpen() {
  char *line = "Hello, world!";
  ssize t linelen = 13;
  E.row.size = linelen;
  E.row.chars = malloc(linelen + 1);
  memcpy(E.row.chars, line, linelen);
  E.row.chars[linelen] = '\0';
  E.numrows = 1;
}




void initEditor() { … }
int main() {
  enableRawMode();
  initEditor();
  editorOpen();
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }
  

malloc() comes from standard lib.h. ssize t comes from <sys/types.h.

editorOpen() will eventually be for opening and reading a file from disk, so we put it in a new  section. To load our “Hello, world” message into the editor’s erow struct, we set the size field to the length of our message, malloc() the necessary memory, and memcpy() the message to the chars field which points to the memory we allocated. Finally, we set the E.numrows variable to 1, to indicate that the erow now contains a line that should be displayed. Let’s display it then.

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    if (y >= E.numrows) {
      if (y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprint F (welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
      int len = E.row.size;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, E.row.chars, len);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }

We wrap our previous row-drawing code in an if statement that checks whether we are currently drawing a row that is part of the text buffer, or a row that comes after the end of the text buffer.

To draw a row that’s part of the text buffer, we simply write out the chars field of the erow. But first, we take care to truncate the rendered line if it would go past the end of the screen.

Next, let’s allow the user to open an actual file. We’ll read and display the first line of the file.

void editorOpen(char *filename) {
  FILE *fp = fopen(filename, "r");
  if (!fp) die("fopen");
  char *line = NULL;
  size t linecap = 0;
  ssize t linelen;
  linelen = getline(&line, &linecap, fp);
  if (linelen != -1) {
    while (linelen > 0 && (line[linelen - 1] == '\n' ||
                           line[linelen - 1] == '\r'))
      linelen--;
    E.row.size = linelen;
    E.row.chars = malloc(linelen + 1);
    memcpy(E.row.chars, line, linelen);
    E.row.chars[linelen] = '\0';
    E.numrows = 1;
  }
  free(line);
  fclose(fp);
}




void initEditor() { … }
int main(int argc, char *argv[]) {
  enableRawMode();
  initEditor();
  if (argc >= 2) {
    editorOpen(argv[1]);
  }
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }
  
♋︎ may or may not compile
FILE, fopen(), and getline() come from standard I O dot H.

The core of editorOpen() is the same, we just get the line and linelen values from getline() now, instead of hardcoded values.

editorOpen() now takes a filename and opens the file for reading using fopen(). We allow the user to choose a file to open by checking if they passed a filename as a command line argument. If they did, we call editorOpen() and pass it the filename. If they ran ./kilo with no arguments, editorOpen() will not be called and they’ll start with a blank file.

getline() is useful for reading lines from a file when we don’t know how much memory to allocate for each line. It takes care of memory management for you. First, we pass it a null line pointer and a linecap (line capacity) of 0. That makes it allocate new memory for the next line it reads, and set line to point to the memory, and set linecap to let you know how much memory it allocated. Its return value is the length of the line it read, or -1 if it’s at the end of the file and there are no more lines to read. Later, when we have editorOpen() read multiple lines of a file, we will be able to feed the new line and linecap values back into getline() over and over, and it will try and reuse the memory that line points to as long as the linecap is big enough to fit the next line it reads. For now, we just copy the one line it reads into E.row.chars, and then free() the line that getline() allocated.

We also strip off the newline or carriage return at the end of the line before copying it into our erow. We know each erow represents one line of text, so there’s no use storing a newline character at the end of each one.

If your compiler complains about getline(), you may need to define a feature test macro. Even if it compiles fine on your machine without them, let’s add them to make our code more portable.

define  DEFAULT SOURCE
define  BSD SOURCE
define  GNU SOURCE




include string.h.

include sys/types.h.











We add them above our includes, because the header files we’re including use the macros to decide what features to expose.

Now let’s fix a quick bug. We want the welcome message to only display when the user starts the program with no arguments, and not when they open a file, as the welcome message could get in the way of displaying the file.

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    if (y >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprint F (welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
      int len = E.row.size;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, E.row.chars, len);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }



There, now the welcome message only displays if the text buffer is completely empty.

Multiple lines
To store multiple lines, let’s make E.row an array of erow structs. It will be a dynamically-allocated array, so we’ll make it a pointer to erow, and initialize the pointer to NULL. (This will break a bunch of our code that doesn’t expect E.row to be a pointer, so the program will fail to compile for the next few steps.)

typedef struct erow { … } erow;
struct editorConfig {
  int cx, cy;
  int screenrows;
  int screencols;
  int numrows;
  erow *row;
  struct termios orig termios;
};
struct editorConfig E;






void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.numrows = 0;
  E.row = NULL;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
int main(int argc, char *argv[]) { … }

Next, let’s move the code in editorOpen() that initializes E.row to a new function called editorAppendRow().

void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int editorReadKey() { … }
int getCursorPosition(int *rows, int *cols) { … }
int getWindowSize(int *rows, int *cols) { … }
/
void editorAppendRow(char *s, size t len) {
  E.row.size = len;
  E.row.chars = malloc(len + 1);
  memcpy(E.row.chars, s, len);
  E.row.chars[len] = '\0';
  E.numrows = 1;
}

void editorOpen(char *filename) {
  FILE *fp = fopen(filename, "r");
  if (!fp) die("fopen");
  char *line = NULL;
  size t linecap = 0;
  ssize t linelen;
  linelen = getline(&line, &linecap, fp);
  if (linelen != -1) {
    while (linelen > 0 && (line[linelen - 1] == '\n' ||
                           line[linelen - 1] == '\r'))
      linelen--;
    editorAppendRow(line, linelen);
  }
  free(line);
  fclose(fp);
}

Notice that we renamed the line and linelen variables to s and len, which are now arguments to editorAppendRow().

We want editorAppendRow() to allocate space for a new erow, and then copy the given string to a new erow at the end of the E.row array. Let’s do that now.

void editorAppendRow(char *s, size t len) {
  E.row = realloc(E.row, sizeof(erow) * (E.numrows + 1));
  int at = E.numrows;
  E.row[at].size = len;
  E.row[at].chars = malloc(len + 1);
  memcpy(E.row[at].chars, s, len);
  E.row[at].chars[len] = '\0';
  E.numrows++;
}

We have to tell realloc() how many bytes we want to allocate, so we multiply the number of bytes each erow takes (sizeof(erow)) and multiply that by the number of rows we want. Then we set at to the index of the new row we want to initialize, and replace each occurrence of E.row with E.row[at]. Lastly, we change E.numrows = 1 to E.numrows++.

Next, let’s update editorDrawRows() to use E.row[y] instead of E.row, when printing out the current line.

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    if (y >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprint F (welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
      int len = E.row[y].size;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, E.row[y].chars, len);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }



At this point the code should compile, but it still only reads a single line from the file. Let’s add a while loop to editorOpen() to read an entire file into E.row.

void editorOpen(char *filename) {
  FILE *fp = fopen(filename, "r");
  if (!fp) die("fopen");
  char *line = NULL;
  size t linecap = 0;
  ssize t linelen;
  while ((linelen = getline(&line, &linecap, fp)) != -1) {
    while (linelen > 0 && (line[linelen - 1] == '\n' ||
                           line[linelen - 1] == '\r'))
      linelen--;
    editorAppendRow(line, linelen);
  }
  free(line);
  fclose(fp);
}





The while loop works because getline() returns -1 when it gets to the end of the file and there are no more lines to read.

Now you should see your screen fill up with lines of text when you run ./kilo kilo.c, for example.

Vertical scrolling
Next we want to enable the user to scroll through the whole file, instead of just being able to see the top few lines of the file. Let’s add a rowoff (row offset) variable to the global editor state, which will keep track of what row of the file the user is currently scrolled to.

typedef struct erow { … } erow;
struct editorConfig {
  int cx, cy;
  int rowoff;
  int screenrows;
  int screencols;
  int numrows;
  erow *row;
  struct termios orig termios;
};
struct editorConfig E;

/





void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.rowoff = 0;
  E.numrows = 0;
  E.row = NULL;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
int main(int argc, char *argv[]) { … }

We initialize it to 0, which means we’ll be scrolled to the top of the file by default.

Now let’s have editorDrawRows() display the correct range of lines of the file according to the value of rowoff.

void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    int filerow = y + E.rowoff;
    if (filerow >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprint F (welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
      int len = E.row[filerow].size;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, E.row[filerow].chars, len);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }



To get the row of the file that we want to display at each y position, we add E.rowoff to the y position. So we define a new variable filerow that contains that value, and use that as the index into E.row.

Now where do we set the value of E.rowoff? Our strategy will be to check if the cursor has moved outside of the visible window, and if so, adjust E.rowoff so that the cursor is just inside the visible window. We’ll put this logic in a function called editorScroll(), and call it right before we refresh the screen.

void editorScroll() {
  if (E.cy < E.rowoff) {
    E.rowoff = E.cy;
  }
  if (E.cy >= E.rowoff + E.screenrows) {
    E.rowoff = E.cy - E.screenrows + 1;
  }
}
void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() {
  editorScroll();
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  char buf[32];
  snprint F (buf, sizeof(buf), "\x1b[%d;%dH", E.cy + 1, E.cx + 1);
  abAppend(&ab, buf, strlen(buf));
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}



The first if statement checks if the cursor is above the visible window, and if so, scrolls up to where the cursor is. The second if statement checks if the cursor is past the bottom of the visible window, and contains slightly more complicated arithmetic because E.rowoff refers to what’s at the top of the screen, and we have to get E.screenrows involved to talk about what’s at the bottom of the screen.

Now let’s allow the cursor to advance past the bottom of the screen (but not past the bottom of the file).

void editorMoveCursor(int key) {
  switch (key) {
    case ARROW LEFT:
      if (E.cx != 0) {
        E.cx--;
      }
      break;
    case ARROW RIGHT:
      if (E.cx != E.screencols - 1) {
        E.cx++;
      }
      break;
    case ARROW UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW DOWN:
      if (E.cy < E.numrows) {
        E.cy++;
      }
      break;
  }
}
void editorProcessKeypress() { … }


You should be able to scroll through the entire file now, when you run ./kilo kilo.c. (If the file contains tab characters, you’ll see that the characters that the tabs take up aren’t being erased properly when drawing to the screen. We’ll fix this issue soon. In the meantime, you may want to test with a file that doesn’t contain a lot of tabs.)

If you try to scroll back up, you may notice the cursor isn’t being positioned properly. That is because E.cy no longer refers to the position of the cursor on the screen. It refers to the position of the cursor within the text file. To position the cursor on the screen, we now have to subtract E.rowoff from the value of E.cy.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() {
  editorScroll();
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  char buf[32];
  snprint F (buf, sizeof(buf), "\x1b[%d;%dH", (E.cy - E.rowoff) + 1, E.cx + 1);
  abAppend(&ab, buf, strlen(buf));
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}



Horizontal scrolling
Now let’s work on horizontal scrolling. We’ll implement it in just about the same way we implemented vertical scrolling. Start by adding a coloff (column offset) variable to the global editor state.

typedef struct erow { … } erow;
struct editorConfig {
  int cx, cy;
  int rowoff;
  int coloff;
  int screenrows;
  int screencols;
  int numrows;
  erow *row;
  struct termios orig termios;
};
struct editorConfig E;

/





void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.rowoff = 0;
  E.coloff = 0;
  E.numrows = 0;
  E.row = NULL;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
int main(int argc, char *argv[]) { … }

To display each row at the column offset, we’ll use E.coloff as an index into the chars of each erow we display, and subtract the number of characters that are to the left of the offset from the length of the row.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    int filerow = y + E.rowoff;
    if (filerow >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprint F (welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
      int len = E.row[filerow].size - E.coloff;
      if (len < 0) len = 0;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, &E.row[filerow].chars[E.coloff], len);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }



Note that when subtracting E.coloff from the length, len can now be a negative number, meaning the user scrolled horizontally past the end of the line. In that case, we set len to 0 so that nothing is displayed on that line.

Now let’s update editorScroll() to handle horizontal scrolling.

void editorScroll() {
  if (E.cy < E.rowoff) {
    E.rowoff = E.cy;
  }
  if (E.cy >= E.rowoff + E.screenrows) {
    E.rowoff = E.cy - E.screenrows + 1;
  }
  if (E.cx < E.coloff) {
    E.coloff = E.cx;
  }
  if (E.cx >= E.coloff + E.screencols) {
    E.coloff = E.cx - E.screencols + 1;
  }
}
void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() { … }



As you can see, it is exactly parallel to the vertical scrolling code. We just replace E.cy with E.cx, E.rowoff with E.coloff, and E.screenrows with E.screencols.

Now let’s allow the user to scroll past the right edge of the screen.

void editorMoveCursor(int key) {
  switch (key) {
    case ARROW LEFT:
      if (E.cx != 0) {
        E.cx--;
      }
      break;
    case ARROW RIGHT:
      if (E.cx != E.screencols - 1) {
      E.cx++;
      }
      break;
    case ARROW UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW DOWN:
      if (E.cy < E.numrows) {
        E.cy++;
      }
      break;
  }
}
void editorProcessKeypress() { … }


You should be able to confirm that horizontal scrolling now works.

Next, let’s fix the cursor positioning, just like we did with vertical scrolling.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() {
  editorScroll();
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  char buf[32];
  snprint F (buf, sizeof(buf), "\x1b[%d;%dH", (E.cy - E.rowoff) + 1,
                                            (E.cx - E.coloff) + 1);
  abAppend(&ab, buf, strlen(buf));
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}



Limit scrolling to the right
Now both E.cx and E.cy refer to the cursor’s position within the file, not its position on the screen. So our goal with the next few steps is to limit the values of E.cx and E.cy to only ever point to valid positions in the file. Otherwise, the user could move the cursor way off to the right of a line and start inserting text there, which wouldn’t make much sense. (The only exceptions to this rule are that E.cx can point one character past the end of a line so that characters can be inserted at the end of the line, and E.cy can point one line past the end of the file so that new lines at the end of the file can be added easily.)

Let’s start by not allowing the user to scroll past the end of the current line.

void editorMoveCursor(int key) {
  erow *row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];
  switch (key) {
    case ARROW LEFT:
      if (E.cx != 0) {
        E.cx--;
      }
      break;
    case ARROW RIGHT:
      if (row && E.cx < row->size) {
        E.cx++;
      }
      break;
    case ARROW UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW DOWN:
      if (E.cy < E.numrows) {
        E.cy++;
      }
      break;
  }
}
void editorProcessKeypress() { … }


Since E.cy is allowed to be one past the last line of the file, we use the ternary operator to check if the cursor is on an actual line. If it is, then the row variable will point to the erow that the cursor is on, and we’ll check whether E.cx is to the left of the end of that line before we allow the cursor to move to the right.

Snap cursor to end of line
The user is still able to move the cursor past the end of a line, however. They can do it by moving the cursor to the end of a long line, then moving it down to the next line, which is shorter. The E.cx value won’t change, and the cursor will be off to the right of the end of the line it’s now on.

Let’s add some code to editorMoveCursor() that corrects E.cx if it ends up past the end of the line it’s on.

void editorMoveCursor(int key) {
  erow *row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];
  switch (key) {
    case ARROW LEFT:
      if (E.cx != 0) {
        E.cx--;
      }
      break;
    case ARROW RIGHT:
      if (row && E.cx < row->size) {
        E.cx++;
      }
      break;
    case ARROW UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW DOWN:
      if (E.cy < E.numrows) {
        E.cy++;
      }
      break;
  }
  row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];
  int rowlen = row ? row->size : 0;
  if (E.cx > rowlen) {
    E.cx = rowlen;
  }
}
void editorProcessKeypress() { … }


We have to set row again, since E.cy could point to a different line than it did before. We then set E.cx to the end of that line if E.cx is to the right of the end of that line. Also note that we consider a NULL line to be of length 0, which works for our purposes here.

Moving left at the start of a line
Let’s allow the user to press ← at the beginning of the line to move to the end of the previous line.

void editorMoveCursor(int key) {
  erow *row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];
  switch (key) {
    case ARROW LEFT:
      if (E.cx != 0) {
        E.cx--;
      } else if (E.cy > 0) {
        E.cy--;
        E.cx = E.row[E.cy].size;
      }
      break;
    case ARROW RIGHT:
      if (row && E.cx < row->size) {
        E.cx++;
      }
      break;
    case ARROW UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW DOWN:
      if (E.cy < E.numrows) {
        E.cy++;
      }
      break;
  }
  row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];
  int rowlen = row ? row->size : 0;
  if (E.cx > rowlen) {
    E.cx = rowlen;
  }
}
void editorProcessKeypress() { … }


We make sure they aren’t on the very first line before we move them up a line.

Moving right at the end of a line
Similarly, let’s allow the user to press → at the end of a line to go to the beginning of the next line.

void editorMoveCursor(int key) {
  erow *row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];
  switch (key) {
    case ARROW LEFT:
      if (E.cx != 0) {
        E.cx--;
      } else if (E.cy > 0) {
        E.cy--;
        E.cx = E.row[E.cy].size;
      }
      break;
    case ARROW RIGHT:
      if (row && E.cx < row->size) {
        E.cx++;
      } else if (row && E.cx == row->size) {
        E.cy++;
        E.cx = 0;
      }
      break;
    case ARROW UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW DOWN:
      if (E.cy < E.numrows) {
        E.cy++;
      }
      break;
  }
  row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];
  int rowlen = row ? row->size : 0;
  if (E.cx > rowlen) {
    E.cx = rowlen;
  }
}
void editorProcessKeypress() { … }


Here we have to make sure they’re not at the end of the file before moving down a line.

Rendering tabs
If you try opening the Makefile using ./kilo Makefile, you’ll notice that the tab character on the second line of the Makefile takes up a width of 8 columns or so. The length of a tab is up to the terminal being used and its settings. We want to know the length of each tab, and we also want control over how to render tabs, so we’re going to add a second string to the erow struct called render, which will contain the actual characters to draw on the screen for that row of text. We’ll only use render for tabs for now, but in the future it could be used to render nonprintable control characters as a ^ character followed by another character, such as ^A for the Ctrl-A character (this is a common way to display control characters in the terminal).

You may also notice that when the tab character in the Makefile is displayed by the terminal, it doesn’t erase any characters on the screen within that tab. All a tab does is move the cursor forward to the next tab stop, similar to a carriage return or newline. This is another reason why we want to render tabs as multiple spaces, since spaces erase whatever character was there before.

So, let’s start by adding render and rsize (which contains the size of the contents of render) to the erow struct, and initializing them in editorAppendRow(), which is where new erows get constructed and initialized.

typedef struct erow {
  int size;
  int rsize;
  char *chars;
  char *render;
} erow;
struct editorConfig { … };
struct editorConfig E;

/
void editorAppendRow(char *s, size t len) {
  E.row = realloc(E.row, sizeof(erow) * (E.numrows + 1));
  int at = E.numrows;
  E.row[at].size = len;
  E.row[at].chars = malloc(len + 1);
  memcpy(E.row[at].chars, s, len);
  E.row[at].chars[len] = '\0';
  E.row[at].rsize = 0;
  E.row[at].render = NULL;
  E.numrows++;
}






Next, let’s make an editorUpdateRow() function that uses the chars string of an erow to fill in the contents of the render string. We’ll copy each character from chars to render. We won’t worry about how to render tabs just yet.

void editorUpdateRow(erow *row) {
  free(row->render);
  row->render = malloc(row->size + 1);
  int j;
  int idx = 0;
  for (j = 0; j < row->size; j++) {
    row->render[idx++] = row->chars[j];
  }
  row->render[idx] = '\0';
  row->rsize = idx;
}
void editorAppendRow(char *s, size t len) {
  E.row = realloc(E.row, sizeof(erow) * (E.numrows + 1));
  int at = E.numrows;
  E.row[at].size = len;
  E.row[at].chars = malloc(len + 1);
  memcpy(E.row[at].chars, s, len);
  E.row[at].chars[len] = '\0';
  E.row[at].rsize = 0;
  E.row[at].render = NULL;
  editorUpdateRow(&E.row[at]);
  E.numrows++;
}






After the for loop, idx contains the number of characters we copied into row->render, so we assign it to row->rsize.

Now let’s replace chars and size with render and rsize in editorDrawRows(), when we display each erow.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    int filerow = y + E.rowoff;
    if (filerow >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprint F (welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
      int len = E.row[filerow].rsize - E.coloff;
      if (len < 0) len = 0;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, &E.row[filerow].render[E.coloff], len);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
      abAppend(ab, "\r\n", 2);
    }
  }
}
void editorRefreshScreen() { … }



Now the text viewer is displaying the characters in render. Let’s add code to editorUpdateRow() that renders tabs as multiple space characters.

void editorUpdateRow(erow *row) {
  int tabs = 0;
  int j;
  for (j = 0; j < row->size; j++)
    if (row->chars[j] == '\t') tabs++;
  free(row->render);
  row->render = malloc(row->size + tabs*7 + 1);
  int idx = 0;
  for (j = 0; j < row->size; j++) {
    if (row->chars[j] == '\t') {
      row->render[idx++] = ' ';
      while (idx % 8 != 0) row->render[idx++] = ' ';
    } else {
      row->render[idx++] = row->chars[j];
    }
  }
  row->render[idx] = '\0';
  row->rsize = idx;
}
void editorAppendRow(char *s, size t len) { … }






First, we have to loop through the chars of the row and count the tabs in order to know how much memory to allocate for render. The maximum number of characters needed for each tab is 8. row->size already counts 1 for each tab, so we multiply the number of tabs by 7 and add that to row->size to get the maximum amount of memory we’ll need for the rendered row.

After allocating the memory, we modify the for loop to check whether the current character is a tab. If it is, we append one space (because each tab must advance the cursor forward at least one column), and then append spaces until we get to a tab stop, which is a column that is divisible by 8.

At this point, we should probably make the length of a tab stop a constant.

define KILO VERSION "0.0.1"
define KILO TAB STOP 8
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey { … };


/
void editorUpdateRow(erow *row) {
  int tabs = 0;
  int j;
  for (j = 0; j < row->size; j++)
    if (row->chars[j] == '\t') tabs++;
  free(row->render);
  row->render = malloc(row->size + tabs*(KILO TAB STOP - 1) + 1);
  int idx = 0;
  for (j = 0; j < row->size; j++) {
    if (row->chars[j] == '\t') {
      row->render[idx++] = ' ';
      while (idx % KILO TAB STOP != 0) row->render[idx++] = ' ';
    } else {
      row->render[idx++] = row->chars[j];
    }
  }
  row->render[idx] = '\0';
  row->rsize = idx;
}
void editorAppendRow(char *s, size t len) { … }






This makes the code clearer, and also makes the tab stop length configurable.

Tabs and the cursor
The cursor doesn’t currently interact with tabs very well. When we position the cursor on the screen, we’re still assuming each character takes up only one column on the screen. To fix this, let’s introduce a new horizontal coordinate variable, E.rx. While E.cx is an index into the chars field of an erow, the E.rx variable will be an index into the render field. If there are no tabs on the current line, then E.rx will be the same as E.cx. If there are tabs, then E.rx will be greater than E.cx by however many extra spaces those tabs take up when rendered.

Start by adding rx to the global state struct, and initializing it to 0.

typedef struct erow { … } erow;
struct editorConfig {
  int cx, cy;
  int rx;
  int rowoff;
  int coloff;
  int screenrows;
  int screencols;
  int numrows;
  erow *row;
  struct termios orig termios;
};
struct editorConfig E;

/





void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.rx = 0;
  E.rowoff = 0;
  E.coloff = 0;
  E.numrows = 0;
  E.row = NULL;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
}
int main(int argc, char *argv[]) { … }

We’ll set the value of E.rx at the top of editorScroll(). For now we’ll just set it to be the same as E.cx. Then we’ll replace all instances of E.cx with E.rx in editorScroll(), because scrolling should take into account the characters that are actually rendered to the screen, and the rendered position of the cursor.

void editorScroll() {
  E.rx = E.cx;
  if (E.cy < E.rowoff) {
    E.rowoff = E.cy;
  }
  if (E.cy >= E.rowoff + E.screenrows) {
    E.rowoff = E.cy - E.screenrows + 1;
  }
  if (E.rx < E.coloff) {
    E.coloff = E.rx;
  }
  if (E.rx >= E.coloff + E.screencols) {
    E.coloff = E.rx - E.screencols + 1;
  }
}
void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() { … }



Now change E.cx to E.rx in editorRefreshScreen() where we set the cursor position.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() {
  editorScroll();
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  char buf[32];
  snprint F (buf, sizeof(buf), "\x1b[%d;%dH", (E.cy - E.rowoff) + 1,
                                            (E.rx - E.coloff) + 1);
  abAppend(&ab, buf, strlen(buf));
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}



All that’s left to do is calculate the value of E.rx properly in editorScroll(). Let’s create an editorRowCxToRx() function that converts a chars index into a render index. We’ll need to loop through all the characters to the left of cx, and figure out how many spaces each tab takes up.

int editorRowCxToRx(erow *row, int cx) {
  int rx = 0;
  int j;
  for (j = 0; j < cx; j++) {
    if (row->chars[j] == '\t')
      rx += (KILO TAB STOP - 1) - (rx % KILO TAB STOP);
    rx++;
  }
  return rx;
}
void editorUpdateRow(erow *row) { … }
void editorAppendRow(char *s, size t len) { … }






For each character, if it’s a tab we use rx % KILO TAB STOP to find out how many columns we are to the right of the last tab stop, and then subtract that from KILO TAB STOP - 1 to find out how many columns we are to the left of the next tab stop. We add that amount to rx to get just to the left of the next tab stop, and then the unconditional rx++ statement gets us right on the next tab stop. Notice how this works even if we are currently on a tab stop.

Let’s call editorRowCxToRx() at the top of editorScroll() to finally set E.rx to its proper value.

void editorScroll() {
  E.rx = 0;
  if (E.cy < E.numrows) {
    E.rx = editorRowCxToRx(&E.row[E.cy], E.cx);
  }
  if (E.cy < E.rowoff) {
    E.rowoff = E.cy;
  }
  if (E.cy >= E.rowoff + E.screenrows) {
    E.rowoff = E.cy - E.screenrows + 1;
  }
  if (E.rx < E.coloff) {
    E.coloff = E.rx;
  }
  if (E.rx >= E.coloff + E.screencols) {
    E.coloff = E.rx - E.screencols + 1;
  }
}
void editorDrawRows(struct abuf *ab) { … }
void editorRefreshScreen() { … }



You should now be able to confirm that the cursor moves properly within lines that contain tabs.

Scrolling with Page Up and Page Down
Now that we have scrolling, let’s make the Page Up and Page Down keys scroll up or down an entire page.

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      E.cx = E.screencols - 1;
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        if (c == PAGE UP) {
          E.cy = E.rowoff;
        } else if (c == PAGE DOWN) {
          E.cy = E.rowoff + E.screenrows - 1;
          if (E.cy > E.numrows) E.cy = E.numrows;
        }
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
  }
}


To scroll up or down a page, we position the cursor either at the top or bottom of the screen, and then simulate an entire screen’s worth of ↑ or ↓ keypresses. Delegating to editorMoveCursor() takes care of all the bounds-checking and cursor-fixing that needs to be done when moving the cursor.

Move to the end of the line with End
Now let’s have the End key move the cursor to the end of the current line. (The Home key already moves the cursor to the beginning of the line, since we made E.cx relative to the file instead of relative to the screen.)

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      if (E.cy < E.numrows)
        E.cx = E.row[E.cy].size;
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        if (c == PAGE UP) {
          E.cy = E.rowoff;
        } else if (c == PAGE DOWN) {
          E.cy = E.rowoff + E.screenrows - 1;
          if (E.cy > E.numrows) E.cy = E.numrows;
        }
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
  }
}


The End key brings the cursor to the end of the current line. If there is no current line, then E.cx must be 0 and it should stay at 0, so there’s nothing to do.

Status bar
The last thing we’ll add before finally getting to text editing is a status bar. This will show useful information such as the filename, how many lines are in the file, and what line you’re currently on. Later we’ll add a marker that tells you whether the file has been modified since it was last saved, and we’ll also display the filetype when we implement syntax highlighting.

First we’ll simply make room for a one-line status bar at the bottom of the screen.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    int filerow = y + E.rowoff;
    if (filerow >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprint F (welcome, sizeof(welcome),
          "Kilo editor -- version %s", KILO VERSION);
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
      int len = E.row[filerow].rsize - E.coloff;
      if (len < 0) len = 0;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, &E.row[filerow].render[E.coloff], len);
    }
    abAppend(ab, "\x1b[K", 3);
    if (y < E.screenrows - 1) {
    abAppend(ab, "\r\n", 2);
  }
  }
}
void editorRefreshScreen() { … }


void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.rx = 0;
  E.rowoff = 0;
  E.coloff = 0;
  E.numrows = 0;
  E.row = NULL;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
  E.screenrows -= 1;
}
int main(int argc, char *argv[]) { … }

We decrement E.screenrows so that editorDrawRows() doesn’t try to draw a line of text at the bottom of the screen. We also have editorDrawRows() print a newline after the last row it draws, since the status bar is now the final line being drawn on the screen.

Notice how with those two changes, our text viewer works just fine, including scrolling and cursor movement, and the last line where our status bar will be is left alone by the rest of the display code.

To make the status bar stand out, we’re going to display it with inverted colors: black text on a white background. The escape sequence <esc>[7m switches to inverted colors, and <esc>[m switches back to normal formatting. Let’s draw a blank white status bar of inverted space characters.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) { … }
void editorDrawStatusBar(struct abuf *ab) {
  abAppend(ab, "\x1b[7m", 4);
  int len = 0;
  while (len < E.screencols) {
    abAppend(ab, " ", 1);
    len++;
  }
  abAppend(ab, "\x1b[m", 3);
}
void editorRefreshScreen() {
  editorScroll();
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  editorDrawStatusBar(&ab);
  char buf[32];
  snprint F (buf, sizeof(buf), "\x1b[%d;%dH", (E.cy - E.rowoff) + 1,
                                            (E.rx - E.coloff) + 1);
  abAppend(&ab, buf, strlen(buf));
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}



The m command (Select Graphic Rendition) causes the text printed after it to be printed with various possible attributes including bold (1), underscore (4), blink (5), and inverted colors (7). For example, you could specify all of these attributes using the command <esc>[1;4;5;7m. An argument of 0 clears all attributes, and is the default argument, so we use <esc>[m to go back to normal text formatting.

Since we want to display the filename in the status bar, let’s add a filename string to the global editor state, and save a copy of the filename there when a file is opened.

typedef struct erow { … } erow;
struct editorConfig {
  int cx, cy;
  int rx;
  int rowoff;
  int coloff;
  int screenrows;
  int screencols;
  int numrows;
  erow *row;
  char *filename;
  struct termios orig termios;
};
struct editorConfig E;

/

void editorOpen(char *filename) {
  free(E.filename);
  E.filename = strdup(filename);
  FILE *fp = fopen(filename, "r");
  if (!fp) die("fopen");
  char *line = NULL;
  size t linecap = 0;
  ssize t linelen;
  while ((linelen = getline(&line, &linecap, fp)) != -1) {
    while (linelen > 0 && (line[linelen - 1] == '\n' ||
                           line[linelen - 1] == '\r'))
      linelen--;
    editorAppendRow(line, linelen);
  }
  free(line);
  fclose(fp);
}




void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.rx = 0;
  E.rowoff = 0;
  E.coloff = 0;
  E.numrows = 0;
  E.row = NULL;
  E.filename = NULL;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
  E.screenrows -= 1;
}
int main(int argc, char *argv[]) { … }

strdup() comes from string.h. It makes a copy of the given string, allocating the required memory and assuming you will free() that memory.

We initialize E.filename to the NULL pointer, and it will stay NULL if a file isn’t opened (which is what happens when the program is run without arguments).

Now we’re ready to display some information in the status bar. We’ll display up to 20 characters of the filename, followed by the number of lines in the file. If there is no filename, we’ll display [No Name] instead.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) { … }
void editorDrawStatusBar(struct abuf *ab) {
  abAppend(ab, "\x1b[7m", 4);
  char status[80];
  int len = snprint F (status, sizeof(status), "%.20s - %d lines",
    E.filename ? E.filename : "[No Name]", E.numrows);
  if (len > E.screencols) len = E.screencols;
  abAppend(ab, status, len);
  while (len < E.screencols) {
    abAppend(ab, " ", 1);
    len++;
  }
  abAppend(ab, "\x1b[m", 3);
}
void editorRefreshScreen() { … }



We make sure to cut the status string short in case it doesn’t fit inside the width of the window. Notice how we still use the code that draws spaces up to the end of the screen, so that the entire status bar has a white background.

Now let’s show the current line number, and align it to the right edge of the screen.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) { … }
void editorDrawStatusBar(struct abuf *ab) {
  abAppend(ab, "\x1b[7m", 4);
  char status[80], rstatus[80];
  int len = snprint F (status, sizeof(status), "%.20s - %d lines",
    E.filename ? E.filename : "[No Name]", E.numrows);
  int rlen = snprint F (rstatus, sizeof(rstatus), "%d/%d",
    E.cy + 1, E.numrows);
  if (len > E.screencols) len = E.screencols;
  abAppend(ab, status, len);
  while (len < E.screencols) {
    if (E.screencols - len == rlen) {
      abAppend(ab, rstatus, rlen);
      break;
    } else {
      abAppend(ab, " ", 1);
      len++;
    }
  }
  abAppend(ab, "\x1b[m", 3);
}
void editorRefreshScreen() { … }



The current line is stored in E.cy, which we add 1 to since E.cy is 0-indexed. After printing the first status string, we want to keep printing spaces until we get to the point where if we printed the second status string, it would end up against the right edge of the screen. That happens when E.screencols - len is equal to the length of the second status string. At that point we print the status string and break out of the loop, as the entire status bar has now been printed.

Status message
We’re going to add one more line below our status bar. This will be for displaying messages to the user, and prompting the user for input when doing a search, for example. We’ll store the current message in a string called statusmsg, which we’ll put in the global editor state. We’ll also store a timestamp for the message, so that we can erase it a few seconds after it’s been displayed.

define  DEFAULT SOURCE
define  BSD SOURCE
define  GNU SOURCE




include string.h.

include sys/types.h.

include time.h.



typedef struct erow { … } erow;
struct editorConfig {
  int cx, cy;
  int rx;
  int rowoff;
  int coloff;
  int screenrows;
  int screencols;
  int numrows;
  erow *row;
  char *filename;
  char statusmsg[80];
  time t statusmsg time;
  struct termios orig termios;
};
struct editorConfig E;

/





void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.rx = 0;
  E.rowoff = 0;
  E.coloff = 0;
  E.numrows = 0;
  E.row = NULL;
  E.filename = NULL;
  E.statusmsg[0] = '\0';
  E.statusmsg time = 0;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
  E.screenrows -= 1;
}
int main(int argc, char *argv[]) { … }

time t comes from <time.h.

We initialize E.statusmsg to an empty string, so no message will be displayed by default. E.statusmsg time will contain the timestamp when we set a status message.

Let’s define an editorSetStatusMessage() function. This function will take a format string and a variable number of arguments, like the print F () family of functions.

define  DEFAULT SOURCE
define  BSD SOURCE
define  GNU SOURCE



include stdarg.h.

include string.h.

include sys/types.h.

include time.h.




/



void editorScroll() { … }
void editorDrawRows(struct abuf *ab) { … }
void editorDrawStatusBar(struct abuf *ab) { … }
void editorRefreshScreen() { … }
void editorSetStatusMessage(const char *fmt, ..) {
  va list ap;
  va start(ap, fmt);
  vsnprint F (E.statusmsg, sizeof(E.statusmsg), fmt, ap);
  va end(ap);
  E.statusmsg time = time(NULL);
}


void initEditor() { … }
int main(int argc, char *argv[]) {
  enableRawMode();
  initEditor();
  if (argc >= 2) {
    editorOpen(argv[1]);
  }
  editorSetStatusMessage("HELP: Ctrl-Q = quit");
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }
  

va list, va start(), and va end() come from <stdarg.h. vsnprint F () comes from standard I O dot H. time() comes from <time.h.

In main(), we set the initial status message to a help message with the key bindings that our text editor uses (currently, just Ctrl-Q to quit).

vsnprint F () helps us make our own print F ()-style function. We store the resulting string in E.statusmsg, and set E.statusmsg time to the current time, which can be gotten by passing NULL to time(). (It returns the number of seconds that have passed since midnight, January 1, 1970 as an integer.)

The .. argument makes editorSetStatusMessage() a variadic function, meaning it can take any number of arguments. C’s way of dealing with these arguments is by having you call va start() and va end() on a value of type va list. The last argument before the .. (in this case, fmt) must be passed to va start(), so that the address of the next arguments is known. Then, between the va start() and va end() calls, you would call va arg() and pass it the type of the next argument (which you usually get from the given format string) and it would return the value of that argument. In this case, we pass fmt and ap to vsnprint F () and it takes care of reading the format string and calling va arg() to get each argument.

Now that we have a status message to display, let’s make room for a second line beneath our status bar where we’ll display the message.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) { … }
void editorDrawStatusBar(struct abuf *ab) {
  abAppend(ab, "\x1b[7m", 4);
  char status[80], rstatus[80];
  int len = snprint F (status, sizeof(status), "%.20s - %d lines",
    E.filename ? E.filename : "[No Name]", E.numrows);
  int rlen = snprint F (rstatus, sizeof(rstatus), "%d/%d",
    E.cy + 1, E.numrows);
  if (len > E.screencols) len = E.screencols;
  abAppend(ab, status, len);
  while (len < E.screencols) {
    if (E.screencols - len == rlen) {
      abAppend(ab, rstatus, rlen);
      break;
    } else {
      abAppend(ab, " ", 1);
      len++;
    }
  }
  abAppend(ab, "\x1b[m", 3);
  abAppend(ab, "\r\n", 2);
}
void editorRefreshScreen() { … }
void editorSetStatusMessage(const char *fmt, ..) { … }


void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.rx = 0;
  E.rowoff = 0;
  E.coloff = 0;
  E.numrows = 0;
  E.row = NULL;
  E.filename = NULL;
  E.statusmsg[0] = '\0';
  E.statusmsg time = 0;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
  E.screenrows -= 2;
}
int main(int argc, char *argv[]) { … }

We decrement E.screenrows again, and print a newline after the first status bar. We now have a blank final line once again.

Let’s draw the message bar in a new editorDrawMessageBar() function.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) { … }
void editorDrawStatusBar(struct abuf *ab) { … }
void editorDrawMessageBar(struct abuf *ab) {
  abAppend(ab, "\x1b[K", 3);
  int msglen = strlen(E.statusmsg);
  if (msglen > E.screencols) msglen = E.screencols;
  if (msglen && time(NULL) - E.statusmsg time < 5)
    abAppend(ab, E.statusmsg, msglen);
}
void editorRefreshScreen() {
  editorScroll();
  struct abuf ab = ABUF INIT;
  abAppend(&ab, "\x1b[?25l", 6);
  abAppend(&ab, "\x1b[H", 3);
  editorDrawRows(&ab);
  editorDrawStatusBar(&ab);
  editorDrawMessageBar(&ab);
  char buf[32];
  snprint F (buf, sizeof(buf), "\x1b[%d;%dH", (E.cy - E.rowoff) + 1,
                                            (E.rx - E.coloff) + 1);
  abAppend(&ab, buf, strlen(buf));
  abAppend(&ab, "\x1b[?25h", 6);
  write(standard out FILENO, ab.b, ab.len);
  abFree(&ab);
}
void editorSetStatusMessage(const char *fmt, ..) { … }



First we clear the message bar with the <esc>[K escape sequence. Then we make sure the message will fit the width of the screen, and then display the message, but only if the message is less than 5 seconds old.

When you start up the program now, you should see the help message at the bottom. It will disappear when you press a key after 5 seconds. Remember, we only refresh the screen after each keypress.

In the next chapter, we will turn our text viewer into a text editor, allowing the user to insert and delete characters and save their changes to disk.

A text editor.
Let’s begin by writing a function that inserts a single character into an erow, at a given position.

int editorRowCxToRx(erow *row, int cx) { … }
void editorUpdateRow(erow *row) { … }
void editorAppendRow(char *s, size t len) { … }
void editorRowInsertChar(erow *row, int at, int c) {
  if (at < 0 || at > row->size) at = row->size;
  row->chars = realloc(row->chars, row->size + 2);
  memmove(&row->chars[at + 1], &row->chars[at], row->size - at + 1);
  row->size++;
  row->chars[at] = c;
  editorUpdateRow(row);
}






memmove() comes from string.h. It is like memcpy(), but is safe to use when the source and destination arrays overlap.

First we validate at, which is the index we want to insert the character into. Notice that at is allowed to go one character past the end of the string, in which case the character should be inserted at the end of the string.

Then we allocate one more byte for the chars of the erow (we add 2 because we also have to make room for the null byte), and use memmove() to make room for the new character. We increment the size of the chars array, and then actually assign the character to its position in the array. Finally, we call editorUpdateRow() so that the render and rsize fields get updated with the new row content.

Now we’ll create a new section called . This section will contain functions that we’ll call from editorProcessKeypress() when we’re mapping keypresses to various text editing operations. We’ll add a function to this section called editorInsertChar() which will take a character and use editorRowInsertChar() to insert that character into the position that the cursor is at.

int editorRowCxToRx(erow *row, int cx) { … }
void editorUpdateRow(erow *row) { … }
void editorAppendRow(char *s, size t len) { … }
void editorRowInsertChar(erow *row, int at, int c) { … }

void editorInsertChar(int c) {
  if (E.cy == E.numrows) {
    editorAppendRow("", 0);
  }
  editorRowInsertChar(&E.row[E.cy], E.cx, c);
  E.cx++;
}






If E.cy == E.numrows, then the cursor is on the tilde line after the end of the file, so we need to append a new row to the file before inserting a character there. After inserting a character, we move the cursor forward so that the next character the user inserts will go after the character just inserted.

Notice that editorInsertChar() doesn’t have to worry about the details of modifying an erow, and editorRowInsertChar() doesn’t have to worry about where the cursor is. That is the difference between functions in the  section and functions in the / section.

Let’s call editorInsertChar() in the default: case of the switch statement in editorProcessKeypress(). This will allow any keypress that isn’t mapped to another editor function to be inserted directly into the text being edited.

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      if (E.cy < E.numrows)
        E.cx = E.row[E.cy].size;
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        if (c == PAGE UP) {
          E.cy = E.rowoff;
        } else if (c == PAGE DOWN) {
          E.cy = E.rowoff + E.screenrows - 1;
          if (E.cy > E.numrows) E.cy = E.numrows;
        }
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
    default:
      editorInsertChar(c);
      break;
  }
}


We’ve now officially upgraded our text viewer to a text editor.

Prevent inserting special characters
Currently, if you press keys like Backspace or Enter, those characters will be inserted directly into the text, which we certainly don’t want. Let’s handle a bunch of these special keys in editorProcessKeypress(), so that they don’t fall through to the default case of calling editorInsertChar().

define KILO VERSION "0.0.1"
define KILO TAB STOP 8
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey {
  BACKSPACE = 127,
  ARROW LEFT = 1000,
  ARROW RIGHT,
  ARROW UP,
  ARROW DOWN,
  DEL KEY,
  HOME KEY,
  END KEY,
  PAGE UP,
  PAGE DOWN
};


/





void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case '\r':
      /* TODO */
      break;
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      if (E.cy < E.numrows)
        E.cx = E.row[E.cy].size;
      break;
    case BACKSPACE:
    case CTRL KEY('h'):
    case DEL KEY:
      /* TODO */
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        if (c == PAGE UP) {
          E.cy = E.rowoff;
        } else if (c == PAGE DOWN) {
          E.cy = E.rowoff + E.screenrows - 1;
          if (E.cy > E.numrows) E.cy = E.numrows;
        }
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
    case CTRL KEY('l'):
    case '\x1b':
      break;
    default:
      editorInsertChar(c);
      break;
  }
}


Backspace doesn’t have a human-readable backslash-escape representation in C (like \n, \r, and so on), so we make it part of the editorKey enum and assign it its ASCII value of 127.

In editorProcessKeypress(), the first new key we add to the switch statement is '\r', which is the Enter key. For now we want to ignore it, but obviously we’ll be making it do something later, so we mark it with a TODO comment.

We handle Backspace and Delete in a similar way, marking them with a TODO. We also handle the Ctrl-H key combination, which sends the control code 8, which is originally what the Backspace character would send back in the day. If you look at the ASCII table, you’ll see that ASCII code 8 is named BS for “backspace”, and ASCII code 127 is named DEL for “delete”. But for whatever reason, in modern computers the Backspace key is mapped to 127 and the Delete key is mapped to the escape sequence <esc>[3~, as we saw at the end of chapter 3.

Lastly, we handle Ctrl-L and Escape by not doing anything when those keys are pressed. Ctrl-L is traditionally used to refresh the screen in terminal programs. In our text editor, the screen refreshes after any keypress, so we don’t have to do anything else to implement that feature. We ignore the Escape key because there are many key escape sequences that we aren’t handling (such as the F1–F12 keys), and the way we wrote editorReadKey(), pressing those keys will be equivalent to pressing the Escape key. We don’t want the user to unwittingly insert the escape character 27 into their text, so we ignore those keypresses.

Save to disk
Now that we’ve finally made text editable, let’s implement saving to disk. First we’ll write a function that converts our array of erow structs into a single string that is ready to be written out to a file.

char *editorRowsToString(int *buflen) {
  int totlen = 0;
  int j;
  for (j = 0; j < E.numrows; j++)
    totlen += E.row[j].size + 1;
  *buflen = totlen;
  char *buf = malloc(totlen);
  char *p = buf;
  for (j = 0; j < E.numrows; j++) {
    memcpy(p, E.row[j].chars, E.row[j].size);
    p += E.row[j].size;
    *p = '\n';
    p++;
  }
  return buf;
}
void editorOpen(char *filename) { … }





First we add up the lengths of each row of text, adding 1 to each one for the newline character we’ll add to the end of each line. We save the total length into buflen, to tell the caller how long the string is.

Then, after allocating the required memory, we loop through the rows, and memcpy() the contents of each row to the end of the buffer, appending a newline character after each row.

We return buf, expecting the caller to free() the memory.

Now we’ll implement the editorSave() function, which will actually write the string returned by editorRowsToString() to disk.

define  DEFAULT SOURCE
define  BSD SOURCE
define  GNU SOURCE


include fcntl.h.

include stdarg.h.

include string.h.

include sys/types.h.

include time.h.




/


char *editorRowsToString(int *buflen) { … }
void editorOpen(char *filename) { … }
void editorSave() {
  if (E.filename == NULL) return;
  int len;
  char *buf = editorRowsToString(&len);
  int fd = open(E.filename, O RDWR | O CREAT, 0644);
  ftruncate(fd, len);
  write(fd, buf, len);
  close(fd);
  free(buf);
}





open(), O RDWR, and O CREAT come from <fcntl.h. ftruncate() and close() come from unistd.h.

If it’s a new file, then E.filename will be NULL, and we won’t know where to save the file, so we just return without doing anything for now. Later, we’ll figure out how to prompt the user for a filename.

Otherwise, we call editorRowsToString(), and write() the string to the path in E.filename. We tell open() we want to create a new file if it doesn’t already exist (O CREAT), and we want to open it for reading and writing (O RDWR). Because we used the O CREAT flag, we have to pass an extra argument containing the mode (the permissions) the new file should have. 0644 is the standard permissions you usually want for text files. It gives the owner of the file permission to read and write the file, and everyone else only gets permission to read the file.

ftruncate() sets the file’s size to the specified length. If the file is larger than that, it will cut off any data at the end of the file to make it that length. If the file is shorter, it will add 0 bytes at the end to make it that length.

The normal way to overwrite a file is to pass the O TRUNC flag to open(), which truncates the file completely, making it an empty file, before writing the new data into it. By truncating the file ourselves to the same length as the data we are planning to write into it, we are making the whole overwriting operation a little bit safer in case the ftruncate() call succeeds but the write() call fails. In that case, the file would still contain most of the data it had before. But if the file was truncated completely by the open() call and then the write() failed, you’d end up with all of your data lost.

More advanced editors will write to a new, temporary file, and then rename that file to the actual file the user wants to overwrite, and they’ll carefully check for errors through the whole process.

Anyways, all we have to do now is map a key to editorSave(), so let’s do it! We’ll use Ctrl-S.

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  int c = editorReadKey();
  switch (c) {
    case '\r':
      /* TODO */
      break;
    case CTRL KEY('q'):
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case CTRL KEY('s'):
      editorSave();
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      if (E.cy < E.numrows)
        E.cx = E.row[E.cy].size;
      break;
    case BACKSPACE:
    case CTRL KEY('h'):
    case DEL KEY:
      /* TODO */
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        if (c == PAGE UP) {
          E.cy = E.rowoff;
        } else if (c == PAGE DOWN) {
          E.cy = E.rowoff + E.screenrows - 1;
          if (E.cy > E.numrows) E.cy = E.numrows;
        }
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
    case CTRL KEY('l'):
    case '\x1b':
      break;
    default:
      editorInsertChar(c);
      break;
  }
}


You should be able to open a file in the editor, insert some characters, press Ctrl-S, and reopen the file to confirm that the changes you made were saved.

Let’s add error handling to editorSave().

char *editorRowsToString(int *buflen) { … }
void editorOpen(char *filename) { … }
void editorSave() {
  if (E.filename == NULL) return;
  int len;
  char *buf = editorRowsToString(&len);
  int fd = open(E.filename, O RDWR | O CREAT, 0644);
  if (fd != -1) {
    if (ftruncate(fd, len) != -1) {
      if (write(fd, buf, len) == len) {
        close(fd);
        free(buf);
        return;
      }
    }
    close(fd);
  }
  free(buf);
}





open() and ftruncate() both return -1 on error. We expect write() to return the number of bytes we told it to write. Whether or not an error occurred, we ensure that the file is closed and the memory that buf points to is freed.

Let’s use editorSetStatusMessage() to notify the user whether the save succeeded or not. While we’re at it, we’ll add the Ctrl-S key binding to the help message that’s set in main().

char *editorRowsToString(int *buflen) { … }
void editorOpen(char *filename) { … }
void editorSave() {
  if (E.filename == NULL) return;
  int len;
  char *buf = editorRowsToString(&len);
  int fd = open(E.filename, O RDWR | O CREAT, 0644);
  if (fd != -1) {
    if (ftruncate(fd, len) != -1) {
      if (write(fd, buf, len) == len) {
        close(fd);
        free(buf);
        editorSetStatusMessage("%d bytes written to disk", len);
        return;
      }
    }
    close(fd);
  }
  free(buf);
  editorSetStatusMessage("Can't save! I/O error: %s", strerror(errno));
}




void initEditor() { … }
int main(int argc, char *argv[]) {
  enableRawMode();
  initEditor();
  if (argc >= 2) {
    editorOpen(argv[1]);
  }
  editorSetStatusMessage("HELP: Ctrl-S = save | Ctrl-Q = quit");
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }
  

strerror() comes from string.h.

strerror() is like perror() (which we use in die()), but it takes the errno value as an argument and returns the human-readable string for that error code, so that we can make the error a part of the status message we display to the user.

The above code doesn’t actually compile, because we are trying to call editorSetStatusMessage() before it is defined in the file. You can’t do that in C, because C was made to be a language that can be compiled in a single pass, meaning it should be possible to compile each part of a program without knowing what comes later in the program.

When we call a function in C, the compiler needs to know the arguments and return value of that function. We can tell the compiler this information about editorSetStatusMessage() by declaring a function prototype for it near the top of the file. This allows us to call the function before it is defined.

typedef struct erow { … } erow;
struct editorConfig { … };
struct editorConfig E;

void editorSetStatusMessage(const char *fmt, ..);

/




We’d like to keep track of whether the text loaded in our editor differs from what’s in the file. Then we can warn the user that they might lose unsaved changes when they try to quit.

We call a text buffer “dirty” if it has been modified since opening or saving the file. Let’s add a dirty variable to the global editor state, and initialize it to 0.


typedef struct erow { … } erow;
struct editorConfig {
  int cx, cy;
  int rx;
  int rowoff;
  int coloff;
  int screenrows;
  int screencols;
  int numrows;
  erow *row;
  int dirty;
  char *filename;
  char statusmsg[80];
  time t statusmsg time;
  struct termios orig termios;
};
struct editorConfig E;

void initEditor() {
  E.cx = 0;
  E.cy = 0;
  E.rx = 0;
  E.rowoff = 0;
  E.coloff = 0;
  E.numrows = 0;
  E.row = NULL;
  E.dirty = 0;
  E.filename = NULL;
  E.statusmsg[0] = '\0';
  E.statusmsg time = 0;
  if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
  E.screenrows -= 2;
}
int main(int argc, char *argv[]) { … }

Let’s show the state of E.dirty in the status bar, by displaying (modified) after the filename if the file has been modified.

void editorScroll() { … }
void editorDrawRows(struct abuf *ab) { … }
void editorDrawStatusBar(struct abuf *ab) {
  abAppend(ab, "\x1b[7m", 4);
  char status[80], rstatus[80];
  int len = snprint F (status, sizeof(status), "%.20s - %d lines %s",
    E.filename ? E.filename : "[No Name]", E.numrows,
    E.dirty ? "(modified)" : "");
  int rlen = snprint F (rstatus, sizeof(rstatus), "%d/%d",
    E.cy + 1, E.numrows);
  if (len > E.screencols) len = E.screencols;
  abAppend(ab, status, len);
  while (len < E.screencols) {
    if (E.screencols - len == rlen) {
      abAppend(ab, rstatus, rlen);
      break;
    } else {
      abAppend(ab, " ", 1);
      len++;
    }
  }
  abAppend(ab, "\x1b[m", 3);
  abAppend(ab, "\r\n", 2);
}
void editorDrawMessageBar(struct abuf *ab) { … }
void editorRefreshScreen() { … }
void editorSetStatusMessage(const char *fmt, ..) { … }



Now let’s increment E.dirty in each row operation that makes a change to the text.

int editorRowCxToRx(erow *row, int cx) { … }
void editorUpdateRow(erow *row) { … }
void editorAppendRow(char *s, size t len) {
  E.row = realloc(E.row, sizeof(erow) * (E.numrows + 1));
  int at = E.numrows;
  E.row[at].size = len;
  E.row[at].chars = malloc(len + 1);
  memcpy(E.row[at].chars, s, len);
  E.row[at].chars[len] = '\0';
  E.row[at].rsize = 0;
  E.row[at].render = NULL;
  editorUpdateRow(&E.row[at]);
  E.numrows++;
  E.dirty++;
}
void editorRowInsertChar(erow *row, int at, int c) {
  if (at < 0 || at > row->size) at = row->size;
  row->chars = realloc(row->chars, row->size + 2);
  memmove(&row->chars[at + 1], &row->chars[at], row->size - at + 1);
  row->size++;
  row->chars[at] = c;
  editorUpdateRow(row);
  E.dirty++;
}







We could have used E.dirty = 1 instead of E.dirty++, but by incrementing it we can have a sense of “how dirty” the file is, which could be useful. (We’ll just be treating E.dirty as a boolean value in this tutorial, so it doesn’t really matter.)

If you open a file at this point, you’ll see that (modified) appears right away, before you make any changes. That’s because editorOpen() calls editorAppendRow(), which increments E.dirty. To fix that, let’s reset E.dirty to 0 at the end of editorOpen(), and also in editorSave().

char *editorRowsToString(int *buflen) { … }
void editorOpen(char *filename) {
  free(E.filename);
  E.filename = strdup(filename);
  FILE *fp = fopen(filename, "r");
  if (!fp) die("fopen");
  char *line = NULL;
  size t linecap = 0;
  ssize t linelen;
  while ((linelen = getline(&line, &linecap, fp)) != -1) {
    while (linelen > 0 && (line[linelen - 1] == '\n' ||
                           line[linelen - 1] == '\r'))
      linelen--;
    editorAppendRow(line, linelen);
  }
  free(line);
  fclose(fp);
  E.dirty = 0;
}
void editorSave() {
  if (E.filename == NULL) return;
  int len;
  char *buf = editorRowsToString(&len);
  int fd = open(E.filename, O RDWR | O CREAT, 0644);
  if (fd != -1) {
    if (ftruncate(fd, len) != -1) {
      if (write(fd, buf, len) == len) {
        close(fd);
        free(buf);
        E.dirty = 0;
        editorSetStatusMessage("%d bytes written to disk", len);
        return;
      }
    }
    close(fd);
  }
  free(buf);
  editorSetStatusMessage("Can't save! I/O error: %s", strerror(errno));
}





Now you should see (modified) appear in the status bar when you first insert a character, and you should see it disappear when you save the file to disk.

Quit confirmation
Now we’re ready to warn the user about unsaved changes when they try to quit. If E.dirty is set, we will display a warning in the status bar, and require the user to press Ctrl-Q three more times in order to quit without saving.

define KILO VERSION "0.0.1"
define KILO TAB STOP 8
define KILO QUIT TIMES 3
define CTRL KEY(k) ((k) & 0x1f)
enum editorKey { … };

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  static int quit times = KILO QUIT TIMES;
  int c = editorReadKey();
  switch (c) {
    case '\r':
      /* TODO */
      break;
    case CTRL KEY('q'):
      if (E.dirty && quit times > 0) {
        editorSetStatusMessage("WARNING!!! File has unsaved changes. "
          "Press Ctrl-Q %d more times to quit.", quit times);
        quit times--;
        return;
      }
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case CTRL KEY('s'):
      editorSave();
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      if (E.cy < E.numrows)
        E.cx = E.row[E.cy].size;
      break;
    case BACKSPACE:
    case CTRL KEY('h'):
    case DEL KEY:
      /* TODO */
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        if (c == PAGE UP) {
          E.cy = E.rowoff;
        } else if (c == PAGE DOWN) {
          E.cy = E.rowoff + E.screenrows - 1;
          if (E.cy > E.numrows) E.cy = E.numrows;
        }
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
    case CTRL KEY('l'):
    case '\x1b':
      break;
    default:
      editorInsertChar(c);
      break;
  }
  quit times = KILO QUIT TIMES;
}


We use a static variable in editorProcessKeypress() to keep track of how many more times the user must press Ctrl-Q to quit. Each time they press Ctrl-Q with unsaved changes, we set the status message and decrement quit times. When quit times gets to 0, we finally allow the program to exit. When they press any key other than Ctrl-Q, then quit times gets reset back to 3 at the end of the editorProcessKeypress() function.

Simple backspacing
Let’s implement backspacing next. First we’ll create an editorRowDelChar() function, which deletes a character in an erow.

int editorRowCxToRx(erow *row, int cx) { … }
void editorUpdateRow(erow *row) { … }
void editorAppendRow(char *s, size t len) { … }
void editorRowInsertChar(erow *row, int at, int c) { … }
void editorRowDelChar(erow *row, int at) {
  if (at < 0 || at >= row->size) return;
  memmove(&row->chars[at], &row->chars[at + 1], row->size - at);
  row->size--;
  editorUpdateRow(row);
  E.dirty++;
}







As you can see, it’s very similar to editorRowInsertChar(), except we don’t have any memory management to do. We just use memmove() to overwrite the deleted character with the characters that come after it (notice that the null byte at the end gets included in the move). Then we decrement the row’s size, call editorUpdateRow(), and increment E.dirty.

Now let’s implement editorDelChar(), which uses editorRowDelChar() to delete the character that is to the left of the cursor.

void editorInsertChar(int c) { … }
void editorDelChar() {
  if (E.cy == E.numrows) return;
  erow *row = &E.row[E.cy];
  if (E.cx > 0) {
    editorRowDelChar(row, E.cx - 1);
    E.cx--;
  }
}






If the cursor’s past the end of the file, then there is nothing to delete, and we return immediately. Otherwise, we get the erow the cursor is on, and if there is a character to the left of the cursor, we delete it and move the cursor one to the left.

Let’s map the Backspace, Ctrl-H, and Delete keys to editorDelChar().

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  static int quit times = KILO QUIT TIMES;
  int c = editorReadKey();
  switch (c) {
    case '\r':
      /* TODO */
      break;
    case CTRL KEY('q'):
      if (E.dirty && quit times > 0) {
        editorSetStatusMessage("WARNING!!! File has unsaved changes. "
          "Press Ctrl-Q %d more times to quit.", quit times);
        quit times--;
        return;
      }
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case CTRL KEY('s'):
      editorSave();
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      if (E.cy < E.numrows)
        E.cx = E.row[E.cy].size;
      break;
    case BACKSPACE:
    case CTRL KEY('h'):
    case DEL KEY:
      if (c == DEL KEY) editorMoveCursor(ARROW RIGHT);
      editorDelChar();
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        if (c == PAGE UP) {
          E.cy = E.rowoff;
        } else if (c == PAGE DOWN) {
          E.cy = E.rowoff + E.screenrows - 1;
          if (E.cy > E.numrows) E.cy = E.numrows;
        }
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
    case CTRL KEY('l'):
    case '\x1b':
      break;
    default:
      editorInsertChar(c);
      break;
  }
  quit times = KILO QUIT TIMES;
}


It so happens that in our editor, pressing the → key and then Backspace is equivalent to what you would expect from pressing the Delete key in a text editor: it deletes the character to the right of the cursor. So that is how we implement the Delete key above.

Backspacing at the start of a line
Currently, editorDelChar() doesn’t do anything when the cursor is at the beginning of a line. When the user backspaces at the beginning of a line, we want to append the contents of that line to the previous line, and then delete the current line. This effectively backspaces the implicit \n character in between the two lines to join them into one line.

So we need two new row operations: one for appending a string to a row, and one for deleting a row. Let’s start by implementing editorDelRow(), which will also require an editorFreeRow() function for freeing the memory owned by the erow we are deleting.

int editorRowCxToRx(erow *row, int cx) { … }
void editorUpdateRow(erow *row) { … }
void editorAppendRow(char *s, size t len) { … }
void editorFreeRow(erow *row) {
  free(row->render);
  free(row->chars);
}
void editorDelRow(int at) {
  if (at < 0 || at >= E.numrows) return;
  editorFreeRow(&E.row[at]);
  memmove(&E.row[at], &E.row[at + 1], sizeof(erow) * (E.numrows - at - 1));
  E.numrows--;
  E.dirty++;
}
void editorRowInsertChar(erow *row, int at, int c) { … }
void editorRowDelChar(erow *row, int at) { … }







editorDelRow() looks a lot like editorRowDelChar(), because in both cases we are deleting a single element from an array of elements by its index.

First we validate the at index. Then we free the memory owned by the row using editorFreeRow(). We then use memmove() to overwrite the deleted row struct with the rest of the rows that come after it, and decrement numrows. Finally, we increment E.dirty.

Now let’s implement editorRowAppendString(), which appends a string to the end of a row.

int editorRowCxToRx(erow *row, int cx) { … }
void editorUpdateRow(erow *row) { … }
void editorAppendRow(char *s, size t len) { … }
void editorFreeRow(erow *row) { … }
void editorDelRow(int at) { … }
void editorRowInsertChar(erow *row, int at, int c) { … }
void editorRowAppendString(erow *row, char *s, size t len) {
  row->chars = realloc(row->chars, row->size + len + 1);
  memcpy(&row->chars[row->size], s, len);
  row->size += len;
  row->chars[row->size] = '\0';
  editorUpdateRow(row);
  E.dirty++;
}
void editorRowDelChar(erow *row, int at) { … }







The row’s new size is row->size + len + 1 (including the null byte), so first we allocate that much memory for row->chars. Then we simply memcpy() the given string to the end of the contents of row->chars. We update row->size, call editorUpdateRow() as usual, and increment E.dirty as usual.

Now we’re ready to get editorDelChar() to handle the case where the cursor is at the beginning of a line.

void editorInsertChar(int c) { … }
void editorDelChar() {
  if (E.cy == E.numrows) return;
  if (E.cx == 0 && E.cy == 0) return;
  erow *row = &E.row[E.cy];
  if (E.cx > 0) {
    editorRowDelChar(row, E.cx - 1);
    E.cx--;
  } else {
    E.cx = E.row[E.cy - 1].size;
    editorRowAppendString(&E.row[E.cy - 1], row->chars, row->size);
    editorDelRow(E.cy);
    E.cy--;
  }
}






If the cursor is at the beginning of the first line, then there’s nothing to do, so we return immediately. Otherwise, if we find that E.cx == 0, we call editorRowAppendString() and then editorDelRow() as we planned. row points to the row we are deleting, so we append row->chars to the previous row, and then delete the row that E.cy is on. We set E.cx to the end of the contents of the previous row before appending to that row. That way, the cursor will end up at the point where the two lines joined.

Notice that pressing the Delete key at the end of a line works as the user would expect, joining the current line with the next line. This is because moving the cursor to the right at the end of a line moves it to the beginning of the next line. So making the Delete key an alias for the → key followed by the Backspace key still works.

The Enter key
The last editor operation we have to implement is the Enter key. The Enter key allows the user to insert new lines into the text, or split a line into two lines. The first thing we need to do is rename the editorAppendRow(..) function to editorInsertRow(int at, ..). It will now be able to insert a row at the index specified by the new at argument.

int editorRowCxToRx(erow *row, int cx) { … }
void editorUpdateRow(erow *row) { … }
void editorInsertRow(int at, char *s, size t len) {
  if (at < 0 || at > E.numrows) return;
  E.row = realloc(E.row, sizeof(erow) * (E.numrows + 1));
  memmove(&E.row[at + 1], &E.row[at], sizeof(erow) * (E.numrows - at));
  int at = E.numrows;
  E.row[at].size = len;
  E.row[at].chars = malloc(len + 1);
  memcpy(E.row[at].chars, s, len);
  E.row[at].chars[len] = '\0';
  E.row[at].rsize = 0;
  E.row[at].render = NULL;
  editorUpdateRow(&E.row[at]);
  E.numrows++;
  E.dirty++;
}
void editorFreeRow(erow *row) { … }
void editorDelRow(int at) { … }
void editorRowInsertChar(erow *row, int at, int c) { … }
void editorRowAppendString(erow *row, char *s, size t len) { … }
void editorRowDelChar(erow *row, int at) { … }







Much like editorRowInsertChar(), we first validate at, then allocate memory for one more erow, and use memmove() to make room at the specified index for the new row.

We also delete the old int at = .. line, since at is now being passed in as an argument.

We now have to replace all calls to editorAppendRow(..) with calls to editorInsertRow(E.numrows, ..).

void editorInsertChar(int c) {
  if (E.cy == E.numrows) {
    editorInsertRow(E.numrows, "", 0);
  }
  editorRowInsertChar(&E.row[E.cy], E.cx, c);
  E.cx++;
}
void editorDelChar() { … }

char *editorRowsToString(int *buflen) { … }
void editorOpen(char *filename) {
  free(E.filename);
  E.filename = strdup(filename);
  FILE *fp = fopen(filename, "r");
  if (!fp) die("fopen");
  char *line = NULL;
  size t linecap = 0;
  ssize t linelen;
  while ((linelen = getline(&line, &linecap, fp)) != -1) {
    while (linelen > 0 && (line[linelen - 1] == '\n' ||
                           line[linelen - 1] == '\r'))
      linelen--;
    editorInsertRow(E.numrows, line, linelen);
  }
  free(line);
  fclose(fp);
  E.dirty = 0;
}
void editorSave() { … }





Now that we have editorInsertRow(), we’re ready to implement editorInsertNewline(), which handles an Enter keypress.

void editorInsertChar(int c) { … }
void editorInsertNewline() {
  if (E.cx == 0) {
    editorInsertRow(E.cy, "", 0);
  } else {
    erow *row = &E.row[E.cy];
    editorInsertRow(E.cy + 1, &row->chars[E.cx], row->size - E.cx);
    row = &E.row[E.cy];
    row->size = E.cx;
    row->chars[row->size] = '\0';
    editorUpdateRow(row);
  }
  E.cy++;
  E.cx = 0;
}
void editorDelChar() { … }






If we’re at the beginning of a line, all we have to do is insert a new blank row before the line we’re on.

Otherwise, we have to split the line we’re on into two rows. First we call editorInsertRow() and pass it the characters on the current row that are to the right of the cursor. That creates a new row after the current one, with the correct contents. Then we reassign the row pointer, because editorInsertRow() calls realloc(), which might move memory around on us and invalidate the pointer (yikes). Then we truncate the current row’s contents by setting its size to the position of the cursor, and we call editorUpdateRow() on the truncated row. (editorInsertRow() already calls editorUpdateRow() for the new row.)

In both cases, we increment E.cy, and set E.cx to 0 to move the cursor to the beginning of the row.

Finally, let’s actually map the Enter key to the editorInsertNewline() operation.

void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  static int quit times = KILO QUIT TIMES;
  int c = editorReadKey();
  switch (c) {
    case '\r':
      editorInsertNewline();
      break;
    case CTRL KEY('q'):
      if (E.dirty && quit times > 0) {
        editorSetStatusMessage("WARNING!!! File has unsaved changes. "
          "Press Ctrl-Q %d more times to quit.", quit times);
        quit times--;
        return;
      }
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case CTRL KEY('s'):
      editorSave();
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      if (E.cy < E.numrows)
        E.cx = E.row[E.cy].size;
      break;
    case BACKSPACE:
    case CTRL KEY('h'):
    case DEL KEY:
      if (c == DEL KEY) editorMoveCursor(ARROW RIGHT);
      editorDelChar();
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        if (c == PAGE UP) {
          E.cy = E.rowoff;
        } else if (c == PAGE DOWN) {
          E.cy = E.rowoff + E.screenrows - 1;
          if (E.cy > E.numrows) E.cy = E.numrows;
        }
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
    case CTRL KEY('l'):
    case '\x1b':
      break;
    default:
      editorInsertChar(c);
      break;
  }
  quit times = KILO QUIT TIMES;
}


That concludes all of the text editing operations we are going to implement. If you wish, and if you are brave enough, you may now start using the editor to modify its own code for the rest of the tutorial. If you do, I suggest making regular backups of your work (using git or similar) in case you run into bugs in the editor.

Save as…
Currently, when the user runs ./kilo with no arguments, they get a blank file to edit but have no way of saving. We need a way of prompting the user to input a filename when saving a new file. Let’s make an editorPrompt() function that displays a prompt in the status bar, and lets the user input a line of text after the prompt.

void editorSetStatusMessage(const char *fmt, ..);
void editorRefreshScreen();

char *editorPrompt(char *prompt) {
  size t bufsize = 128;
  char *buf = malloc(bufsize);
  size t buflen = 0;
  buf[0] = '\0';
  while (1) {
    editorSetStatusMessage(prompt, buf);
    editorRefreshScreen();
    int c = editorReadKey();
    if (c == '\r') {
      if (buflen != 0) {
        editorSetStatusMessage("");
        return buf;
      }
    } else if (!iscntrl(c) && c < 128) {
      if (buflen == bufsize - 1) {
        bufsize *= 2;
        buf = realloc(buf, bufsize);
      }
      buf[buflen++] = c;
      buf[buflen] = '\0';
    }
  }
}
void editorMoveCursor(int key) { … }
void editorProcessKeypress() { … }


The user’s input is stored in buf, which is a dynamically allocated string that we initalize to the empty string. We then enter an infinite loop that repeatedly sets the status message, refreshes the screen, and waits for a keypress to handle. The prompt is expected to be a format string containing a %s, which is where the user’s input will be displayed.

When the user presses Enter, and their input is not empty, the status message is cleared and their input is returned. Otherwise, when they input a printable character, we append it to buf. If buflen has reached the maximum capacity we allocated (stored in bufsize), then we double bufsize and allocate that amount of memory before appending to buf. We also make sure that buf ends with a \0 character, because both editorSetStatusMessage() and the caller of editorPrompt() will use it to know where the string ends.

Notice that we have to make sure the input key isn’t one of the special keys in the editorKey enum, which have high integer values. To do that, we test whether the input key is in the range of a char by making sure it is less than 128.

Now let’s prompt the user for a filename in editorSave(), when E.filename is NULL.

void editorSetStatusMessage(const char *fmt, ..);
void editorRefreshScreen();
char *editorPrompt(char *prompt);


char *editorRowsToString(int *buflen) { … }
void editorOpen(char *filename) { … }
void editorSave() {
  if (E.filename == NULL) {
    E.filename = editorPrompt("Save as: %s");
  }
  int len;
  char *buf = editorRowsToString(&len);
  int fd = open(E.filename, O RDWR | O CREAT, 0644);
  if (fd != -1) {
    if (ftruncate(fd, len) != -1) {
      if (write(fd, buf, len) == len) {
        close(fd);
        free(buf);
        E.dirty = 0;
        editorSetStatusMessage("%d bytes written to disk", len);
        return;
      }
    }
    close(fd);
  }
  free(buf);
  editorSetStatusMessage("Can't save! I/O error: %s", strerror(errno));
}





Great, we now have basic “Save as…” functionality. Next, let’s allow the user to press Escape to cancel the input prompt.

char *editorPrompt(char *prompt) {
  size t bufsize = 128;
  char *buf = malloc(bufsize);
  size t buflen = 0;
  buf[0] = '\0';
  while (1) {
    editorSetStatusMessage(prompt, buf);
    editorRefreshScreen();
    int c = editorReadKey();
    if (c == '\x1b') {
      editorSetStatusMessage("");
      free(buf);
      return NULL;
    } else if (c == '\r') {
      if (buflen != 0) {
        editorSetStatusMessage("");
        return buf;
      }
    } else if (!iscntrl(c) && c < 128) {
      if (buflen == bufsize - 1) {
        bufsize *= 2;
        buf = realloc(buf, bufsize);
      }
      buf[buflen++] = c;
      buf[buflen] = '\0';
    }
  }
}
void editorMoveCursor(int key) { … }
void editorProcessKeypress() { … }


When an input prompt is cancelled, we free() the buf ourselves and return NULL. So let’s handle a return value of NULL in editorSave() by aborting the save operation and displaying a “Save aborted” message to the user.

char *editorRowsToString(int *buflen) { … }
void editorOpen(char *filename) { … }
void editorSave() {
  if (E.filename == NULL) {
    E.filename = editorPrompt("Save as: %s (ESC to cancel)");
    if (E.filename == NULL) {
      editorSetStatusMessage("Save aborted");
      return;
    }
  }
  int len;
  char *buf = editorRowsToString(&len);
  int fd = open(E.filename, O RDWR | O CREAT, 0644);
  if (fd != -1) {
    if (ftruncate(fd, len) != -1) {
      if (write(fd, buf, len) == len) {
        close(fd);
        free(buf);
        E.dirty = 0;
        editorSetStatusMessage("%d bytes written to disk", len);
        return;
      }
    }
    close(fd);
  }
  free(buf);
  editorSetStatusMessage("Can't save! I/O error: %s", strerror(errno));
}





(Note: If you’re using Bash on Windows, you will have to press Escape 3 times to get one Escape keypress to register in our program, because the read() calls in editorReadKey() that look for an escape sequence never time out.)

Now let’s allow the user to press Backspace (or Ctrl-H, or Delete) in the input prompt.

char *editorPrompt(char *prompt) {
  size t bufsize = 128;
  char *buf = malloc(bufsize);
  size t buflen = 0;
  buf[0] = '\0';
  while (1) {
    editorSetStatusMessage(prompt, buf);
    editorRefreshScreen();
    int c = editorReadKey();
    if (c == DEL KEY || c == CTRL KEY('h') || c == BACKSPACE) {
      if (buflen != 0) buf[--buflen] = '\0';
    } else if (c == '\x1b') {
      editorSetStatusMessage("");
      free(buf);
      return NULL;
    } else if (c == '\r') {
      if (buflen != 0) {
        editorSetStatusMessage("");
        return buf;
      }
    } else if (!iscntrl(c) && c < 128) {
      if (buflen == bufsize - 1) {
        bufsize *= 2;
        buf = realloc(buf, bufsize);
      }
      buf[buflen++] = c;
      buf[buflen] = '\0';
    }
  }
}
void editorMoveCursor(int key) { … }
void editorProcessKeypress() { … }


In the next chapter, we’ll make use of editorPrompt() to implement an incremental search feature in our editor.

Search
Let’s use editorPrompt() to implement a minimal search feature. When the user types a search query and presses Enter, we’ll loop through all the rows of the file, and if a row contains their query string, we’ll move the cursor to the match.

char *editorRowsToString(int *buflen) { … }
void editorOpen(char *filename) { … }
void editorSave() { … }

void editorFind() {
  char *query = editorPrompt("Search: %s (ESC to cancel)");
  if (query == NULL) return;
  int i;
  for (i = 0; i < E.numrows; i++) {
    erow *row = &E.row[i];
    char *match = strstr(row->render, query);
    if (match) {
      E.cy = i;
      E.cx = match - row->render;
      E.rowoff = E.numrows;
      break;
    }
  }
  free(query);
}





strstr() comes from string.h.

If they pressed Escape to cancel the input prompt, then editorPrompt() returns NULL and we abort the search.

Otherwise, we loop through all the rows of the file. We use strstr() to check if query is a substring of the current row. It returns NULL if there is no match, otherwise it returns a pointer to the matching substring. To convert that into an index that we can set E.cx to, we subtract the row->render pointer from the match pointer, since match is a pointer into the row->render string. Lastly, we set E.rowoff so that we are scrolled to the very bottom of the file, which will cause editorScroll() to scroll upwards at the next screen refresh so that the matching line will be at the very top of the screen. This way, the user doesn’t have to look all over their screen to find where their cursor jumped to, and where the matching line is.

There’s one problem here. Did you notice what we just did wrong? We assigned a render index to E.cx, but E.cx is an index into chars. If there are tabs to the left of the match, the cursor is going to be in the wrong position. We need to convert the render index into a chars index before assigning it to E.cx. Let’s create an editorRowRxToCx() function, which is the opposite of the editorRowCxToRx() function we wrote in chapter 4, but contains a lot of the same code.

int editorRowCxToRx(erow *row, int cx) { … }
int editorRowRxToCx(erow *row, int rx) {
  int cur rx = 0;
  int cx;
  for (cx = 0; cx < row->size; cx++) {
    if (row->chars[cx] == '\t')
      cur rx += (KILO TAB STOP - 1) - (cur rx % KILO TAB STOP);
    cur rx++;
    if (cur rx > rx) return cx;
  }
  return cx;
}
void editorUpdateRow(erow *row) { … }
void editorInsertRow(int at, char *s, size t len) { … }
void editorFreeRow(erow *row) { … }
void editorDelRow(int at) { … }
void editorRowInsertChar(erow *row, int at, int c) { … }
void editorRowAppendString(erow *row, char *s, size t len) { … }
void editorRowDelChar(erow *row, int at) { … }








To convert an rx into a cx, we do pretty much the same thing when converting the other way: loop through the chars string, calculating the current rx value (cur rx) as we go. But instead of stopping when we hit a particular cx value and returning cur rx, we want to stop when cur rx hits the given rx value and return cx.

The return statement at the very end is just in case the caller provided an rx that’s out of range, which shouldn’t happen. The return statement inside the for loop should handle all rx values that are valid indexes into render.

Now let’s call editorRowRxToCx() to convert the matched index to a chars index and assign that to E.cx.

void editorFind() {
  char *query = editorPrompt("Search: %s (ESC to cancel)");
  if (query == NULL) return;
  int i;
  for (i = 0; i < E.numrows; i++) {
    erow *row = &E.row[i];
    char *match = strstr(row->render, query);
    if (match) {
      E.cy = i;
      E.cx = editorRowRxToCx(row, match - row->render);
      E.rowoff = E.numrows;
      break;
    }
  }
  free(query);
}





Finally, let’s map Ctrl-F to the editorFind() function, and add it to the help message we set in main().

char *editorPrompt(char *prompt) { … }
void editorMoveCursor(int key) { … }
void editorProcessKeypress() {
  static int quit times = KILO QUIT TIMES;
  int c = editorReadKey();
  switch (c) {
    case '\r':
      editorInsertNewline();
      break;
    case CTRL KEY('q'):
      if (E.dirty && quit times > 0) {
        editorSetStatusMessage("WARNING!!! File has unsaved changes. "
          "Press Ctrl-Q %d more times to quit.", quit times);
        quit times--;
        return;
      }
      write(standard out FILENO, "\x1b[2J", 4);
      write(standard out FILENO, "\x1b[H", 3);
      exit(0);
      break;
    case CTRL KEY('s'):
      editorSave();
      break;
    case HOME KEY:
      E.cx = 0;
      break;
    case END KEY:
      if (E.cy < E.numrows)
        E.cx = E.row[E.cy].size;
      break;
    case CTRL KEY('f'):
      editorFind();
      break;
    case BACKSPACE:
    case CTRL KEY('h'):
    case DEL KEY:
      if (c == DEL KEY) editorMoveCursor(ARROW RIGHT);
      editorDelChar();
      break;
    case PAGE UP:
    case PAGE DOWN:
      {
        if (c == PAGE UP) {
          E.cy = E.rowoff;
        } else if (c == PAGE DOWN) {
          E.cy = E.rowoff + E.screenrows - 1;
          if (E.cy > E.numrows) E.cy = E.numrows;
        }
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE UP ? ARROW UP : ARROW DOWN);
      }
      break;
    case ARROW UP:
    case ARROW DOWN:
    case ARROW LEFT:
    case ARROW RIGHT:
      editorMoveCursor(c);
      break;
    case CTRL KEY('l'):
    case '\x1b':
      break;
    default:
      editorInsertChar(c);
      break;
  }
  quit times = KILO QUIT TIMES;
}

void initEditor() { … }
int main(int argc, char *argv[]) {
  enableRawMode();
  initEditor();
  if (argc >= 2) {
    editorOpen(argv[1]);
  }
  editorSetStatusMessage(
    "HELP: Ctrl-S = save | Ctrl-Q = quit | Ctrl-F = find");
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress();
  }
  

Incremental search
Now, let’s make our search feature fancy. We want to support incremental search, meaning the file is searched after each keypress when the user is typing in their search query.

To implement this, we’re going to get editorPrompt() to take a callback function as an argument. We’ll have it call this function after each keypress, passing the current search query inputted by the user and the last key they pressed.

void editorSetStatusMessage(const char *fmt, ..);
void editorRefreshScreen();
char *editorPrompt(char *prompt, void (*callback)(char *, int));

char *editorPrompt(char *prompt, void (*callback)(char *, int)) {
  size t bufsize = 128;
  char *buf = malloc(bufsize);
  size t buflen = 0;
  buf[0] = '\0';
  while (1) {
    editorSetStatusMessage(prompt, buf);
    editorRefreshScreen();
    int c = editorReadKey();
    if (c == DEL KEY || c == CTRL KEY('h') || c == BACKSPACE) {
      if (buflen != 0) buf[--buflen] = '\0';
    } else if (c == '\x1b') {
      editorSetStatusMessage("");
      if (callback) callback(buf, c);
      free(buf);
      return NULL;
    } else if (c == '\r') {
      if (buflen != 0) {
        editorSetStatusMessage("");
        if (callback) callback(buf, c);
        return buf;
      }
    } else if (!iscntrl(c) && c < 128) {
      if (buflen == bufsize - 1) {
        bufsize *= 2;
        buf = realloc(buf, bufsize);
      }
      buf[buflen++] = c;
      buf[buflen] = '\0';
    }
    if (callback) callback(buf, c);
  }
}
void editorMoveCursor(int key) { … }
void editorProcessKeypress() { … }


The if statements allow the caller to pass NULL for the callback, in case they don’t want to use a callback. This is the case when we prompt the user for a filename, so let’s pass NULL to editorPrompt() when we do that. We’ll also pass NULL to editorPrompt() in editorFind() for now, to get the code to compile.

char *editorRowsToString(int *buflen) { … }
void editorOpen(char *filename) { … }
void editorSave() {
  if (E.filename == NULL) {
    E.filename = editorPrompt("Save as: %s (ESC to cancel)", NULL);
    if (E.filename == NULL) {
      editorSetStatusMessage("Save aborted");
      return;
    }
  }
  int len;
  char *buf = editorRowsToString(&len);
  int fd = open(E.filename, O RDWR | O CREAT, 0644);
  if (fd != -1) {
    if (ftruncate(fd, len) != -1) {
      if (write(fd, buf, len) == len) {
        close(fd);
        free(buf);
        E.dirty = 0;
        editorSetStatusMessage("%d bytes written to disk", len);
        return;
      }
    }
    close(fd);
  }
  free(buf);
  editorSetStatusMessage("Can't save! I/O error: %s", strerror(errno));
}

void editorFind() {
  char *query = editorPrompt("Search: %s (ESC to cancel)", NULL);
  if (query == NULL) return;
  int i;
  for (i = 0; i < E.numrows; i++) {
    erow *row = &E.row[i];
    char *match = strstr(row->render, query);
    if (match) {
      E.cy = i;
      E.cx = editorRowRxToCx(row, match - row->render);
      E.rowoff = E.numrows;
      break;
    }
  }
  free(query);
}





Now let’s move the actual searching code from editorFind() into a function called editorFindCallback(). Obviously this will be our callback function for editorPrompt().

void editorFindCallback(char *query, int key) {
  if (key == '\r' || key == '\x1b') {
    return;
  }
  int i;
  for (i = 0; i < E.numrows; i++) {
    erow *row = &E.row[i];
    char *match = strstr(row->render, query);
    if (match) {
      E.cy = i;
      E.cx = editorRowRxToCx(row, match - row->render);
      E.rowoff = E.numrows;
      break;
    }
  }
}
void editorFind() {
  char *query = editorPrompt("Search: %s (ESC to cancel)", editorFindCallback);
  if (query) {
    free(query);
  }
}





In the callback, we check if the user pressed Enter or Escape, in which case they are leaving search mode so we return immediately instead of doing another search. Otherwise, after any other keypress, we do another search for the current query string.

That’s all there is to it. We now have incremental search.

Restore cursor position when cancelling search
When the user presses Escape to cancel a search, we want the cursor to go back to where it was when they started the search. To do that, we’ll have to save their cursor position and scroll position, and restore those values after the search is cancelled.

void editorFindCallback(char *query, int key) { … }
void editorFind() {
  int saved cx = E.cx;
  int saved cy = E.cy;
  int saved coloff = E.coloff;
  int saved rowoff = E.rowoff;
  char *query = editorPrompt("Search: %s (ESC to cancel)", editorFindCallback);
  if (query) {
    free(query);
  } else {
    E.cx = saved cx;
    E.cy = saved cy;
    E.coloff = saved coloff;
    E.rowoff = saved rowoff;
  }
}





If query is NULL, that means they pressed Escape, so in that case we restore the values we saved.

Search forward and backward
The last feature we’d like to add is to allow the user to advance to the next or previous match in the file using the arrow keys. The ↑ and ← keys will go to the previous match, and the ↓ and → keys will go to the next match.

We’ll implement this feature using two static variables in our callback. last match will contain the index of the row that the last match was on, or -1 if there was no last match. And direction will store the direction of the search: 1 for searching forward, and -1 for searching backward.

void editorFindCallback(char *query, int key) {
  static int last match = -1;
  static int direction = 1;
  if (key == '\r' || key == '\x1b') {
    last match = -1;
    direction = 1;
    return;
  } else if (key == ARROW RIGHT || key == ARROW DOWN) {
    direction = 1;
  } else if (key == ARROW LEFT || key == ARROW UP) {
    direction = -1;
  } else {
    last match = -1;
    direction = 1;
  }
  int i;
  for (i = 0; i < E.numrows; i++) {
    erow *row = &E.row[i];
    char *match = strstr(row->render, query);
    if (match) {
      E.cy = i;
      E.cx = editorRowRxToCx(row, match - row->render);
      E.rowoff = E.numrows;
      break;
    }
  }
}
void editorFind() { … }





As you can see, we always reset last match to -1 unless an arrow key was pressed. So we’ll only advance to the next or previous match when an arrow key is pressed. You can also see that we always set direction to 1 unless the ← or ↑ key was pressed. So we always search in the forward direction unless the user specifically asks to search backwards from the last match.

If key is '\r' (Enter) or '\x1b' (Escape), that means we’re about to leave search mode. So we reset last match and direction to their initial values to get ready for the next search operation.

Now that we have those variables all set up, let’s put them to use.

void editorFindCallback(char *query, int key) {
  static int last match = -1;
  static int direction = 1;
  if (key == '\r' || key == '\x1b') {
    last match = -1;
    direction = 1;
    return;
  } else if (key == ARROW RIGHT || key == ARROW DOWN) {
    direction = 1;
  } else if (key == ARROW LEFT || key == ARROW UP) {
    direction = -1;
  } else {
    last match = -1;
    direction = 1;
  }
  if (last match == -1) direction = 1;
  int current = last match;
  int i;
  for (i = 0; i < E.numrows; i++) {
    current += direction;
    if (current == -1) current = E.numrows - 1;
    else if (current == E.numrows) current = 0;
    erow *row = &E.row[current];
    char *match = strstr(row->render, query);
    if (match) {
      last match = current;
      E.cy = current;
      E.cx = editorRowRxToCx(row, match - row->render);
      E.rowoff = E.numrows;
      break;
    }
  }
}
void editorFind() { … }





current is the index of the current row we are searching. If there was a last match, it starts on the line after (or before, if we’re searching backwards). If there wasn’t a last match, it starts at the top of the file and searches in the forward direction to find the first match.

The if .. else if causes current to go from the end of the file back to the beginning of the file, or vice versa, to allow a search to “wrap around” the end of a file and continue from the top (or bottom).

When we find a match, we set last match to current, so that if the user presses the arrow keys, we’ll start the next search from that point.

Finally, let’s not forget to update the prompt text to let the user know they can use the arrow keys.

void editorFindCallback(char *query, int key) { … }
void editorFind() {
  int saved cx = E.cx;
  int saved cy = E.cy;
  int saved coloff = E.coloff;
  int saved rowoff = E.rowoff;
  char *query = editorPrompt("Search: %s (Use ESC/Arrows/Enter)",
                             editorFindCallback);
  if (query) {
    free(query);
  } else {
    E.cx = saved cx;
    E.cy = saved cy;
    E.coloff = saved coloff;
    E.rowoff = saved rowoff;
  }
}





In the next chapter, we’ll implement syntax highlighting and filetype detection, to complete our text editor.


